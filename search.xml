<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[矩阵树小结]]></title>
      <url>%2F2017%2F12%2F30%2FMatrixTree%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;这篇博客主要是对矩阵树的一些简要总结。 &emsp;&emsp;一、矩阵树定理基本形式与证明思路&emsp;&emsp;矩阵树定理基本形式：一个无向图的生成树个数等于其拉普拉斯矩阵(度数矩阵-邻接矩阵)的任一余子式的值。 &emsp;&emsp;证明思路： &emsp;&emsp;1、定义$E(G)$为无向图$G$的关联矩阵，若图$G$有$n$个点，$m$条边，则$E(G)$有$n$行$m$列。其定义如下(用$E$代指$E(G)$)： E_{ij}=\begin{equation} \left\{ \begin{array}{lr} 1,&i=v_j\\ -1,&i=u_j\\ 0,&others \end{array} \right. \end{equation}&emsp;&emsp;其中$u_j​$，$v_j​$分别表示第$j​$条边的两个端点。注意到这是一个无向图，所以$u_j​$,$v_j​$的顺序可以调换。 &emsp;&emsp;定义$E’(G)$为$E(G)$去掉任意一行产生的矩阵。 &emsp;&emsp;定理：如果图$G$为一棵树(此时$m=n-1$，$E’(G)$有$n-1$行$n-1$列)，$det(E’(G))^2=1$，否则$det(E’(G))^2=0$(产生了线性组合)。 &emsp;&emsp;由上，有： ans= \sum_{ G'\in\begin{align} \left( \begin{array}{lr} [G]\\ n-1 \end{array} \right) \end{align} } det(E'(G'))^2 = \sum_{ G'\in\begin{aligned} \left( \begin{array}{lr} [G]\\ n-1 \end{array} \right) \end{aligned} } det(E'(G'))det(E'(G')^T)&emsp;&emsp;其中$G$为待计算的图，组合数代表图$G$中任意$n-1$条边组成的新图。 &emsp;&emsp;2、定理(Cauchy-Binet公式)： det(AB)=\sum_{ S\in\begin{align} \left( \begin{array}{lr} [n]\\ m \end{array} \right) \end{align} } det(A_{[m]*S})det(B_{S*[m]})&emsp;&emsp;$[n]$代表$1-n$所有整数组成的集合，组合数代表其大小为$m$的子集。 &emsp;&emsp;该公式中，矩阵$A$有$m$行$n$列，$B$有$n$行$m$列。矩阵下标代表该矩阵提出(行集合$*$列集合)组成的子矩阵。 &emsp;&emsp;结合该公式与答案式，有： ans=det(E'(G))det(E'(G)^T)&emsp;&emsp;3、定理： det(E(G))det(E(G)^T)=det(deg(G)-mat(G))=det(L)&emsp;&emsp;其中$mat(G)​$为$G​$的邻接矩阵($mat(G)_{ij}=i​$与$j​$之间边的数量)，$deg(G)​$为$G​$的度数矩阵($deg(G)_{ij}=[i=j]i​$的度数)。$L=deg(G)-mat(G)​$，即图$G​$的拉普拉斯矩阵。 &emsp;&emsp;这个很好证，考察左式的定义即可。 &emsp;&emsp;由于$E’(G)$为$E(G)$去掉任意一行得到，所以有: ans=det(L')&emsp;&emsp;其中$det(L’)$为$L$去掉$i$行$i$列的余子式$M_{ii}$($i$为不大于$n$的任意正整数)。 &emsp;&emsp;二、变元矩阵树定理&emsp;&emsp;若将邻接矩阵定义为($mat(G)_{ij}=i与j之间边权和$)，度数矩阵定义为($deg(G)_{ij}=[i=j]i$相连边的边权和)，则： ans=det(L')=\sum_T\prod_{e\in{T}}w_e&emsp;&emsp;$T$为图$G$所有生成树，$e$为图$G$中的边，$w_e$为$e$的边权。注意这里的边权可以为实数。 &emsp;&emsp;这个定理可以将矩阵树基本定理推广到概率等加强形式。 &emsp;&emsp;三、有向图矩阵树定理&emsp;&emsp;将邻接矩阵定义为($mat(G)_{ij}=i$到$j$的边数量)，将度数矩阵定义为($deg(G)_{ij}=[i=j]i$的入度)，则$L$去掉第$i$行$i$列得到的余子式$M_{ii}=$以点$i$为根的外向生成树个数。 &emsp;&emsp;若将度数矩阵定义为($deg(G)_{ij}=[i=j]i$的出度)，则$L$去掉第$i$行$i$列得到的余子式$M_{ii}=$以点$i$为根的内向生成树个数。 &emsp;&emsp;变元矩阵树定理同样适用于有向图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ1176 Mokia]]></title>
      <url>%2F2017%2F06%2F28%2FBZOJ1176%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个矩阵，最开始所有值都是0。2种操作:&emsp;&emsp;1、将$(x, y)$位置的值增加a&emsp;&emsp;2、查询左下角$(x_1, y_1)$，右上角$(x_2, y_2)$子矩阵权值和 &emsp;&emsp;第一道cdq分治的题目。&emsp;&emsp;对于一次矩阵操作，我们可以通过线段树套线段树在$O(\log^2 n)$的时间内处理。这样复杂度是正确的，但是有没有更简便的，不用大数据结构的方法？cdq分治便可以解决这样的一个问题。&emsp;&emsp;cdq分治主要运用于离线数据方面，其主要作用可以说是破除查询与修改的时间限制，让查询与修改能够以一个更好的顺序呈现出来，更加方便地被处理。&emsp;&emsp;拿这道题来说吧。如果所有查询都在修改之后，那么这道题有没有更加简便的做法？首先对于2操作，我们可以用矩阵的二维差分来将其转化为查询右上角为$(x, y)​$的前缀矩阵和。然后我们将所有的查询和修改放在一起按$x​$坐标排序，$x​$相同的按$y​$排序，使用一个树状数组记录$y​$坐标信息，当每次扫到一个修改操作时，就把它的修改放到树状数组中，当每次扫到一个查询操作时，由于我们知道修改都在查询之前，于是前面扫到过的修改操作就是所有有可能影响该查询的修改操作。于是我们直接在树状数组里寻找想要的信息即可。&emsp;&emsp;可是题目没有这个条件。那么我们是否可以”变出”这个条件呢？这就是cdq分治的精髓所在。我们将所有的操作按时间排序，接下来，分治这个时间轴。在一个分治区间$[l, r]$中，我们将$[l, mid]$时间内发生的修改操作与$[mid, r]$时间内发生的查询操作拿出来，显然这些提出来的修改操作都在查询操作之前，那么我们就可以用上面的方法更新查询操作了。那么这样就完了吗？对于一个发生在时间点$k(k &gt; mid)$的查询操作，区间$[mid + 1, k - 1]$中的修改操作也可能会对其造成影响。所以继续分治下去就好。&emsp;&emsp;每次分治完别忘了还原临时信息，比如树状数组。&emsp;&emsp;注意清树状数组直接一步一步撤回之前操作，不能用memset，不然复杂度是错的！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a);template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxn = 2000010, maxm = 640010, maxq = 10010;int n, s;int ans[maxq];struct data&#123; int op, t, id, x, y, w; data() &#123; &#125; data(int _op, int _t, int _id, int _x, int _y, int _w): op(_op), t(_t), id(_id), x(_x), y(_y), w(_w) &#123; &#125; bool operator &lt; (const data&amp; rhs) const &#123; return x != rhs.x ? x &lt; rhs.x : y != rhs.y ? y &lt; rhs.y : op &lt; rhs.op; &#125;&#125; c[maxm], tmp[maxm];int cur;namespace BIT&#123; int T[maxn]; void add(int p, int x) &#123; for(; p &lt;= n; p += p &amp; -p) T[p] += x; &#125; int query(int p) &#123; int ret = 0; for(; p; p -= p &amp; -p) ret += T[p]; return ret; &#125;&#125;using namespace BIT;void solve(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; rep(i, l, r) if(c[i].op == 1 &amp;&amp; c[i].t &lt;= mid) add(c[i].y, c[i].w); else if (c[i].op == 2 &amp;&amp; c[i].t &gt; mid) ans[c[i].id] += c[i].w * query(c[i].y); rep(i, l, r) if(c[i].op == 1 &amp;&amp; c[i].t &lt;= mid) add(c[i].y, -c[i].w); int cur1 = l, cur2 = mid + 1; rep(i, l, r) if(c[i].t &lt;= mid) tmp[cur1++] = c[i]; else tmp[cur2++] = c[i]; rep(i, l, r) c[i] = tmp[i]; solve(l, mid); solve(mid + 1, r);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(s); read(n); int op, q = 0; while(read(op) != 3) &#123; if(op == 1) &#123; int x, y, w; read(x); read(y); read(w); c[++cur] = data(1, cur, 0, x, y, w); &#125; else &#123; int x1, y1, x2, y2; ++q; read(x1), read(y1), read(x2), read(y2); c[++cur] = data(2, cur, q, x2, y2, 1); c[++cur] = data(2, cur, q, x1 - 1, y2, -1); c[++cur] = data(2, cur, q, x2, y1 - 1, -1); c[++cur] = data(2, cur, q, x1 - 1, y1 - 1, 1); &#125; &#125; sort(c + 1, c + cur + 1); solve(1, cur); rep(i, 1, q) printf("%d\n", ans[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ3572 世界树]]></title>
      <url>%2F2017%2F06%2F24%2FBZOJ3572%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你一棵树，每次询问给出$m$个关键点，树上的一个点受到离其最近的关键点(如有一样近则取编号最小)控制。求每个关键点控制多少个点。 &emsp;&emsp;本来虚树题只想写一篇博客的，但是这道题有点毒瘤所以又写一篇吧。&emsp;&emsp;首先，把虚树建出来。&emsp;&emsp;接着dp两遍，找出离每个虚树点最近的关键点(虚树点不一定为关键点，这一点应该都清楚)。&emsp;&emsp;然后对于虚树上的每一条边(对应原树的一条链)，找出控制的分界点，即对于边$(u, v)$，找到原树中链$(u, v)$上的点哪些受离$u$近的关键点控制，哪些受离$v$近的关键点控制。这个需要二分一下。&emsp;&emsp;倍增跳到分界点，则链上分界点以下的点及其另外子树都受离$v$近的关键点控制，以上的点及其另外子树都受离$u$近的关键点控制。将答案加上这些点及子树的size总和。&emsp;&emsp;此外就是虚树上的点的另外子树，由于可能会被不同的边计算多次，所以就处理好一起更新即可。&emsp;&emsp;这道题细节很多，计算”另外子树”size的部分需要好好想想，在原来树的size的基础上做一些调整，才能得到想要的答案。&emsp;&emsp;另外一点就是，虚树中弹栈的地方的一个判断是大于等于而不是大于。这个细节非常重要，但又非常容易忽略。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxn = 300010, INF = 0x3f3f3f3f;int n, q;int head[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e;void ae(int x, int y) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; &#125;namespace HLD&#123; int cur, dfn[maxn], dep[maxn], top[maxn], fa[maxn][20], son[maxn], sz[maxn]; void dfs1(int u) &#123; sz[u] = 1; son[u] = 0; rep(i, 1, 19) fa[u][i] = fa[fa[u][i - 1]][i - 1]; erep(i, u) if(v != fa[u][0]) &#123; fa[v][0] = u; dep[v] = dep[u] + 1; dfs1(v); if(sz[v] &gt; sz[son[u]]) son[u] = v; sz[u] += sz[v]; &#125; &#125; void dfs2(int u, int g) &#123; top[u] = g; dfn[u] = ++cur; if(son[u]) dfs2(son[u], g); erep(i, u) if(v != fa[u][0] &amp;&amp; v != son[u]) dfs2(v, v); &#125; int LCA(int u, int v) &#123; while(top[u] != top[v]) (dep[top[u]] &gt; dep[top[v]] ? u = fa[top[u]][0] : v = fa[top[v]][0]); return dep[u] &lt; dep[v] ? u : v; &#125;&#125;using namespace HLD;int a[maxn], p[maxn], k;namespace vtree&#123; int head[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], w[maxn &lt;&lt; 1], e, Time[maxn], cur; int near[maxn], dis[maxn], book[maxn], ans[maxn], res[maxn]; int getw(int u, int v) &#123; return abs(dep[u] - dep[v]); &#125; void ae(int x, int y, int W) &#123; if(Time[x] != cur) &#123; head[x] = 0; Time[x] = cur; &#125; to[++e] = y; nxt[e] = head[x]; head[x] = e; w[e] = W; &#125; bool cmp(const int&amp; x, const int&amp; y) &#123; return dfn[x] &lt; dfn[y]; &#125; void build() &#123; ++cur, e = 0; static int stk[maxn]; int top = 0; sort(p + 1, p + k + 1, cmp); rep(i, 1, k) book[p[i]] = cur; stk[++top] = 1; rep(i, 1 + (p[1] == 1), k) &#123; int u = p[i], lca = LCA(stk[top], u); if(lca == stk[top]) stk[++top] = u; else &#123; while(top &gt;= 2 &amp;&amp; dep[stk[top - 1]] &gt;= dep[lca]) //不是 &gt; !!! &#123; int W = getw(stk[top - 1], stk[top]); ae(stk[top - 1], stk[top], W), ae(stk[top], stk[top - 1], W); --top; &#125; if(stk[top] != lca) &#123; int W = getw(stk[top], lca); ae(stk[top], lca, W), ae(lca, stk[top], W); stk[top] = lca; &#125; stk[++top] = u; &#125; &#125; rep(i, 1, top - 1) &#123; int W = getw(stk[i], stk[i + 1]); ae(stk[i], stk[i + 1], W), ae(stk[i + 1], stk[i], W); &#125; &#125; void dp1(int u, int pre) &#123; res[u] = sz[u]; erep(i, u) if(v != pre) dp1(v, u); dis[u] = INF; if(book[u] == cur) near[u] = u, dis[u] = 0; else erep(i, u) if(v != pre) if(chkmin(dis[u], dis[v] + w[i]) || dis[u] == dis[v] + w[i] &amp;&amp; near[v] &lt; near[u]) near[u] = near[v]; &#125; void dp2(int u, int pre) &#123; erep(i, u) if(v != pre) if(chkmin(dis[v], dis[u] + w[i]) || dis[v] == dis[u] + w[i] &amp;&amp; near[u] &lt; near[v]) near[v] = near[u]; erep(i, u) if(v != pre) dp2(v, u); &#125; void init() &#123; dp1(1, 0); dp2(1, 0); &#125; void dp(int u, int pre) &#123; erep(i, u) if(v != pre) &#123; int x = v; drep(j, 19, 0) if(dep[fa[x][j]] &gt; dep[u]) x = fa[x][j]; res[u] -= sz[x]; if(near[u] == near[v]) ans[near[u]] += sz[x] - sz[v]; else &#123; int L = 0, R = w[i]; if(near[u] &lt; near[v]) &#123; while(L &lt; R) &#123; int mid = (L + R + 1) &gt;&gt; 1; if(dis[v] + mid &lt; dis[u] + w[i] - mid) L = mid; else R = mid - 1; &#125; &#125; else &#123; while(L &lt; R) &#123; int mid = (L + R + 1) &gt;&gt; 1; if(dis[v] + mid &lt;= dis[u] + w[i] - mid) L = mid; else R = mid - 1; &#125; &#125; int h = v; rep(j, 0, 19) if(L &amp; (1 &lt;&lt; j)) h = fa[h][j]; ans[near[v]] += sz[h] - sz[v]; ans[near[u]] += sz[x] - sz[h]; &#125; &#125; ans[near[u]] += res[u]; erep(i, u) if(v != pre) dp(v, u); &#125; void solve() &#123; rep(i, 1, k) ans[a[i]] = 0; dp(1, 0); rep(i, 1, k) printf("%d ", ans[a[i]]); puts(""); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); int u, v; rep(i, 1, n - 1) read(u), read(v), ae(u, v), ae(v, u); dfs1(1); dfs2(1, 1); read(q); while(q--) &#123; read(k); rep(i, 1, k) p[i] = read(a[i]); vtree::build(); vtree::init(); vtree::solve(); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ2286 消耗战]]></title>
      <url>%2F2017%2F06%2F18%2FBZOJ2286%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一棵$n$个点，边带权的树，$m$次询问，每次给出k个关键点，求割掉最小代价的边使1号点不能到达任何关键点。 &emsp;&emsp;很裸的树形dp。但是数据范围太大了，承担不起$O(nm)$的复杂度。&emsp;&emsp;这个时候就需要考虑虚树了。&emsp;&emsp;什么是虚树?sengxian的博客讲得很好，这里就不多说了。&emsp;&emsp;这是我的第一道虚树题。通过这道题也能看出很多细节。虚树的复杂度是时刻都必须要算准、保证好的。经常因为一些数组的初始化等问题使得复杂度直接回到了$O(nm)$。比如虚树的邻接表head数组初始化必须要记时间戳，将当前要用的点head清0，而不能直接调用memset。又比如这道题的dp决策，关键点和非关键点的决策是不同的。那么我们如何记录一个点是不是关键点?开数组的话显然初始化又成了问题。&emsp;&emsp;对于这道题，我们发现在一个关键点下方的关键点dp值是没有任何意义的。所以我们在建虚树的时候就要首先预处理去掉这一类点。这样建出的虚树中关键点均为叶子，于是就不用担心什么了。&emsp;&emsp;还有一点，建出虚树后的一条边等于原图的一条路径，那么边权怎么办?这道题中我们可以规避这个问题。令$mine[u]$为u到1号点路径中最小的边权，仅仅利用这个东西我们就能进行dp了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;typedef long long LL;const int maxn = 250010;const LL INF = 0x3f3f3f3f3f3f3f3fll;int n, m;int head[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e;LL w[maxn &lt;&lt; 1];void ae(int x, int y, LL c) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; w[e] = c; &#125;namespace HLD&#123; int cur, fa[maxn], dep[maxn], dfn[maxn], top[maxn], son[maxn], sz[maxn]; LL mine[maxn]; void dfs1(int u) &#123; sz[u] = 1; son[u] = 0; erep(i, u) if(v != fa[u]) &#123; fa[v] = u; dep[v] = dep[u] + 1; mine[v] = min(mine[u], w[i]); dfs1(v); if(sz[v] &gt; sz[son[u]]) son[u] = v; sz[u] += sz[v]; &#125; &#125; void dfs2(int u, int g) &#123; dfn[u] = ++cur; top[u] = g; if(son[u]) dfs2(son[u], g); erep(i, u) if(v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); &#125; int LCA(int u, int v) &#123; while(top[u] != top[v]) (dep[top[u]] &gt; dep[top[v]] ? u = fa[top[u]] : v = fa[top[v]]); return dep[u] &lt; dep[v] ? u : v; &#125;&#125;using namespace HLD;namespace vtree&#123; int head[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e, Time[maxn], cur; void ae(int x, int y) &#123; if(Time[x] != cur) &#123; head[x] = 0; Time[x] = cur; &#125; to[++e] = y; nxt[e] = head[x]; head[x] = e; &#125; bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125; void build(int p[], int tot) &#123; ++cur; e = 0; static int stk[maxn]; int top = 0; sort(p + 1, p + tot + 1, cmp); int tmp = 1; rep(i, 2, tot) if(LCA(p[i], p[tmp]) != p[tmp]) p[++tmp] = p[i]; tot = tmp; stk[++top] = 1; rep(i, 1, tot) &#123; int u = p[i], lca = LCA(u, stk[top]); if(lca == stk[top]) stk[++top] = u; else &#123; while(top &gt;= 2 &amp;&amp; dep[stk[top - 1]] &gt;= dep[lca]) &#123; ae(stk[top], stk[top - 1]), ae(stk[top - 1], stk[top]); --top; &#125; if(stk[top] != lca) &#123; ae(lca, stk[top]), ae(stk[top], lca); stk[top] = lca; &#125; stk[++top] = u; &#125; &#125; rep(i, 1, top - 1) ae(stk[i], stk[i + 1]), ae(stk[i + 1], stk[i]); &#125; LL dp(int u, int pre) &#123; LL f = 0; erep(i, u) if(v != pre) f += min(dp(v, u), mine[v]); return !f ? INF : f; &#125;&#125;int a[maxn], k;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); int u, v; LL c; rep(i, 1, n - 1) read(u), read(v), read(c), ae(u, v, c), ae(v, u, c); mine[1] = INF, dfs1(1); dfs2(1, 1); read(m); while(m--) &#123; read(k); rep(i, 1, k) read(a[i]); vtree::build(a, k); printf("%lld\n", vtree::dp(1, 0)); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ1061 志愿者招募]]></title>
      <url>%2F2017%2F06%2F16%2FBZOJ1061%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个项目有$n$天，第$i$天至少需要$A_i$个人。有$m$种志愿者可以招募，每一种可以从第$s_i$天工作到$t_i$天，费用每人$c_i$元。求用最少费用招募志愿者满足要求。 &emsp;&emsp;这道题是经典的流量平衡模型。常用来解决一类特殊的线性规划问题。&emsp;&emsp;根据$n$天每天的供求关系，我们可以列出一系列不等式，最后求最大化一个线性式子。这正是线性规划。&emsp;&emsp;添加上松弛变量变为等式，等式间相减，发现每个变量正好在左边出现一次，在右边出现一次。&emsp;&emsp;这个时候我们就可以以等式为点，将符号为负的变量移到右边。等式左右表示入流量和出流量的平衡。假定左边为出流量，右边为入流量。每个变量由在左边的式子向在右边的式子连边，其中代表志愿者的边费用为$c_i$。将源点右边的常量连边，左边的常量与汇连边。跑一遍费用流，解决问题。&emsp;&emsp;存信息的数组又开小了，调了好久。。。明明可以在线直接把边加了的啊。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a);template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int INF = 0x3f3f3f3f;const int maxn = 1010, maxm = 15000;int n, m;int k[maxn];int head[maxn], nxt[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], e = 1, c[maxm &lt;&lt; 1], w[maxm &lt;&lt; 1];void ae(int x, int y, int C, int W)&#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; c[e] = C; w[e] = W;&#125;namespace MCMF&#123; int S, T, p[maxn]; int dis[maxn], res[maxn], cost; bool inq[maxn]; bool SPFA() &#123; ms(dis, INF); queue&lt;int&gt; q; q.push(S); inq[S] = 1; dis[S] = p[S] = 0; res[S] = INF; while(!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; erep(i, u) if(c[i] &amp;&amp; chkmin(dis[v], dis[u] + w[i])) &#123; res[v] = min(c[i], res[u]); p[v] = i; if(!inq[v]) inq[v] = 1, q.push(v); &#125; &#125; if(dis[T] == INF) return 0; cost += dis[T] * res[T]; for(int u = T; u != S; u = to[p[u] ^ 1]) c[p[u]] -= res[T], c[p[u] ^ 1] += res[T]; return 1; &#125; int maxflow(int s, int t) &#123; S = s, T = t; cost = 0; while(SPFA()); return cost; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); int s = 0, t = n + 2; rep(i, 1, n) read(k[i]); rep(i, 1, m) &#123; int l, r, cost; read(l), read(r), read(cost); ae(l, r + 1, INF, cost), ae(r + 1, l, 0, -cost); &#125; rep(i, 1, n + 1) &#123; if(k[i] &gt; k[i - 1]) ae(s, i, k[i] - k[i - 1], 0), ae(i, s, 0, 0); if(k[i] &lt; k[i - 1] ) ae(i, t, k[i - 1] - k[i], 0), ae(t, i, 0, 0); &#125; rep(i, 2, n + 1) ae(i, i - 1, INF, 0), ae(i - 1, i, 0, 0); printf("%d\n", MCMF::maxflow(s, t)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ3532 Lis]]></title>
      <url>%2F2017%2F06%2F16%2FBZOJ3532%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个三元组序列$(A_i, B_i, C_i)$，求删掉若干项，使剩下项关于$A_i$的最长上升子序列长度减少1，并使得删去项$B_i$之和最小。输出最小值以及删去项按$C_i$排序后的字典序最小的方案。 &emsp;&emsp;这道题如果不输出方案，那么就是一个最小割。首先每一项拆成两个点，中间连权值为删去费用$B_i$的边。将每一项按照$A_i$的dp关系，$A_i &lt; A_j$ 且 $dp_i + 1 = dp_j$ ，即i能转移到j，则i向j连INF边。$dp_i = 1$的由原点向i连INF边，$dp_i = Max$的由i向汇点连INF边。最小割就是答案。&emsp;&emsp;输出方案的话，我们考虑所有最大流之后满流且两端点互不可达的边，只有这些边可能且一定在最小割的某个可行方案中。因为要求字典序最小，我们便从最小的边开始枚举起。枚举到一条边满足条件后，便贪心地加入答案，并且去掉这条边的影响。即该边被割后，其他一些边就没有必要割了，这些边就要排除在条件之外。&emsp;&emsp;怎么排除?退流。例如我们选中一条边$(u, v)$，我们由汇至v，u至源分别再跑一遍网络流，就可以退掉与$(u, v)$相关的流。相当于在原图中没有出现过$(u, v)$这条边，这时还需要割的边再继续考虑下去即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a);#define pb push_back#define SZ(x) (int((x).size()))#define ALL(x) (x).begin(), (x).end()template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxN = 710, INF = 0x3f3f3f3f, maxn = 1410, maxm = 600010;int n;int a[maxN], b[maxN];int f[maxN];struct info&#123; int val, id; bool operator &lt; (const info&amp; rhs) const &#123; return val &lt; rhs.val; &#125;&#125; C[maxN];int head[maxn], nxt[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], c[maxm &lt;&lt; 1], e;void ae(int x, int y, int w) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; c[e] = w; &#125;namespace dinic&#123; int S, T, dis[maxn], cur[maxn]; bool bfs() &#123; queue&lt;int&gt; q; q.push(S); ms(dis, 0); dis[S] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); erep(i, u) if(c[i] &amp;&amp; !dis[v]) dis[v] = dis[u] + 1, q.push(v); &#125; return dis[T]; &#125; int dfs(int u, int flow) &#123; if(u == T) return flow; int res = flow; for(int&amp; i = cur[u]; i; i = nxt[i]) &#123; int v = to[i]; if(c[i] &amp;&amp; dis[u] + 1 == dis[v]) &#123; int d = dfs(v, min(c[i], res)); c[i] -= d; c[i ^ 1] += d; res -= d; if(!res) return flow; &#125; &#125; return flow - res; &#125; int maxflow(int s, int t) &#123; S = s, T = t; int flow = 0; while(bfs()) &#123; memcpy(cur, head, sizeof head); flow += dfs(S, INF); &#125; return flow; &#125;&#125;bool vis[maxn];bool bfs(int s, int t)&#123; queue&lt;int&gt; q; q.push(s); ms(vis, 0); vis[s] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); if(u == t) return 1; erep(i, u) if(c[i] &amp;&amp; !vis[v]) vis[v] = 1, q.push(v); &#125; return 0;&#125;vector&lt;int&gt; ans;void init()&#123; ms(head, 0); e = 1; ms(f, 0); ans.clear();&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif int _; read(_); while(_--) &#123; init(); read(n); int tmp = 0; rep(i, 1, n) read(a[i]); rep(i, 1, n) read(b[i]); rep(i, 1, n) read(C[i].val), C[i].id = i; rep(i, 1, n) rep(j, 0, i - 1) if(a[j] &lt; a[i]) chkmax(f[i], f[j] + 1); rep(i, 1, n) chkmax(tmp, f[i]); rep(i, 1, n) ae(i, n + i, b[i]), ae(n + i, i, 0); rep(i, 1, n) if(f[i] == 1) ae(0, i, INF), ae(i, 0, 0); rep(i, 1, n) if(f[i] == tmp) ae(n + i, 2 * n + 1, INF), ae(2 * n + 1, n + i, 0); rep(i, 1, n) rep(j, i + 1, n) if(a[i] &lt; a[j] &amp;&amp; f[i] + 1 == f[j]) ae(n + i, j, INF), ae(j, n + i, 0); printf("%d ", dinic::maxflow(0, 2 * n + 1)); sort(C + 1, C + n + 1); rep(i, 1, n) &#123; int x = C[i].id; if(c[x * 2] || bfs(x, x + n)) continue; ans.pb(x); dinic::maxflow(2 * n + 1, x + n); dinic::maxflow(x, 0); c[x * 2] = c[x * 2 + 1] = 0; &#125; printf("%d\n", SZ(ans)); sort(ALL(ans)); rep(i, 0, SZ(ans) - 1) printf("%d%c", ans[i], (i == SZ(ans) - 1) ? '\n' : ' '); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ3876 支线剧情]]></title>
      <url>%2F2017%2F06%2F16%2FBZOJ3876%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个DAG，每条路径的起点固定为1，每条边带权，用几条路径，以最少权值代价使整个DAG每条边都至少被覆盖一次。 &emsp;&emsp;每条边至少被覆盖一次，这可以设计成下界为1，上界INF的上下界网络流。但是边带权，而且权最少，要跑费用流?&emsp;&emsp;上下界最小费用可行流!将汇点向源点连边之后原图变成一个无源汇的图。从超级源向超级汇跑一个最小费用最大流即可。因为保证有解，不用担心其他问题。&emsp;&emsp;话说写费用流总是不记得更新p数组(用来记录pre)啊。要注意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a);template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxn = 310, maxm = 16000, INF = 0x3f3f3f3f;int n;int head[maxn], to[maxm &lt;&lt; 1], nxt[maxm &lt;&lt; 1], c[maxm &lt;&lt; 1], w[maxm &lt;&lt; 1], e = 1;void ae(int x, int y, int C, int W) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; c[e] = C; w[e] = W; &#125;namespace MCMF&#123; int S, T, dis[maxn], res[maxn], p[maxn], cost; bool inq[maxn]; bool SPFA() &#123; ms(dis, INF); queue&lt;int&gt; q; ms(inq, 0); q.push(S); dis[S] = p[S] = 0; res[S] = INF; while(!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; erep(i, u) if(c[i] &amp;&amp; chkmin(dis[v], dis[u] + w[i])) &#123; res[v] = min(res[u], c[i]); p[v] = i; if(!inq[v]) q.push(v), inq[v] = 1; &#125; &#125; if(dis[T] == INF) return 0; cost += res[T] * dis[T]; for(int u = T; u != S; u = to[p[u] ^ 1]) c[p[u]] -= res[T], c[p[u] ^ 1] += res[T]; return 1; &#125; int maxflow(int s, int t) &#123; S = s, T = t; cost = 0; while(SPFA()); return cost; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); int s = 0, t = n + 1, ss = n + 2, tt = n + 3; ae(s, 1, INF, 0), ae(1, s, 0, 0); rep(i, 1, n) ae(i, t, INF, 0), ae(t, i, 0, 0); ae(t, s, INF, 0); ae(s, t, 0, 0); rep(i, 1, n) &#123; int k, v, W; read(k); rep(j, 1, k) &#123; read(v), read(W); ae(ss, v, 1, W); ae(v, ss, 0, -W); ae(i, v, INF, W); ae(v, i, 0, -W); ae(i, tt, 1, 0); ae(tt, i, 0, 0); &#125; &#125; printf("%d\n", MCMF::maxflow(ss, tt)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ2132 圈地计划]]></title>
      <url>%2F2017%2F06%2F16%2FBZOJ2132%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个矩形区域，每个小区域可以建商业区或工业区，可以获得不同价值。对每个区域，如果相邻区域建的区不同，则该区域可以获得额外价值。求最大总价值。 &emsp;&emsp;相邻区域相同则获得价值的建模，之前也提到过。只需要新建两个点用对应价值连向两种不同决策。如果对两种决策而言，同时选获得的价值一样，则可以直接将两区域互相连边即可。&emsp;&emsp;那么不同呢?我们发现这个图是一个矩阵，也就是一个二分图。我们将节点黑白染色放在两部，对白节点，源点为建商业区的决策，汇点为建工业区的决策。黑点正好相反。这样我们就巧妙地转化为区域相同的问题了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a);template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxn = 10010, maxm = 60010, INF = 0x3f3f3f3f;int n, m, sum;int head[maxn], nxt[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], c[maxm &lt;&lt; 1], e = 1;void ae(int x, int y, int w) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; c[e] = w; &#125;namespace isap&#123; int S, T, N, gap[maxn], dis[maxn]; int dfs(int u, int flow) &#123; if(u == T) return flow; int res = flow; erep(i, u) if(c[i] &amp;&amp; dis[u] == dis[v] + 1) &#123; int d = dfs(v, min(c[i], res)); c[i] -= d; c[i ^ 1] += d; res -= d; if(!res) return flow; &#125; if(!--gap[dis[u]]) dis[S] = N; ++gap[++dis[u]]; return flow - res; &#125; int maxflow(int s, int t, int tot) &#123; S = s, T = t, N = tot; int flow = 0; ms(gap, 0); ms(dis, 0); for(gap[0] = N; dis[S] &lt; N;) flow += dfs(S, INF); return flow; &#125;&#125;int a[110][110], b[110][110], w[110][110];int d[4][2] = &#123; 0, 1, 0, -1, 1, 0, -1, 0 &#125;;bool in(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m; &#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); int t = n * m + 1; rep(i, 1, n) rep(j, 1, m) sum += read(a[i][j]); rep(i, 1, n) rep(j, 1, m) sum += read(b[i][j]); rep(i, 1, n) rep(j, 1, m) read(w[i][j]); rep(i, 1, n) rep(j, 1, m) &#123; int id = (i - 1) * m + j; if((i &amp; 1) ^ (j &amp; 1)) &#123; ae(0, id, a[i][j]); ae(id, 0, 0); ae(id, t, b[i][j]); ae(t, id, 0); rep(k, 0, 3) &#123; int x = i + d[k][0], y = j + d[k][1]; if(in(x, y)) &#123; int idx = (x - 1) * m + y; ae(id, idx, w[i][j] + w[x][y]); ae(idx, id, 0); ae(idx, id, w[i][j] + w[x][y]); ae(id, idx, 0); sum += w[i][j] + w[x][y]; &#125; &#125; &#125; else &#123; ae(0, id, b[i][j]); ae(id, 0, 0); ae(id, t, a[i][j]); ae(t, id, 0); &#125; &#125; printf("%d\n", sum - isap::maxflow(0, t, t + 1)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ2127 happiness]]></title>
      <url>%2F2017%2F06%2F16%2FBZOJ2127%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:文理分科，全班每个同学分到文科或理科有不同的喜悦值。相邻两个同学同时分到文科和理科有额外喜悦值。求分配方案使总喜悦值最大。 &emsp;&emsp;这道题是比较经典的最小割模型了。&emsp;&emsp;源点文，汇点理，将每个同学与对应点连对应喜悦值的边。处理相邻就新建点，向对应文或理科点连对应喜悦值的边，向两个人连INF。最小割即为答案。&emsp;&emsp;不过这道题调了比较长的时间。最后发现时建点时编号过于”精打细算”，将点数与实际编到的号数混淆导致弄错了。以后建点与边的时候一定要算准，而且在条件允许的情况下开得宽松一些，才可以防止难以调试的错误发生。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a);template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxn = 50010, maxm = 140010, INF = 0x3f3f3f3f;int n, m, tot;int a[110][110], b[110][110], samed_a[110][110], samed_b[110][110], samer_a[110][110], samer_b[110][110];int head[maxn], nxt[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], c[maxm &lt;&lt; 1], e = 1;void ae(int x, int y, int w) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; c[e] = w; &#125;namespace dinic&#123; int S, T, dis[maxn], cur[maxn]; bool bfs() &#123; queue&lt;int&gt; q; ms(dis, 0); q.push(S); dis[S] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); erep(i, u) if(c[i] &amp;&amp; !dis[v]) dis[v] = dis[u] + 1, q.push(v); &#125; return dis[T]; &#125; int dfs(int u, int flow) &#123; if(u == T) return flow; int res = flow; for(int&amp; i = cur[u]; i; i = nxt[i]) &#123; int v = to[i]; if(c[i] &amp;&amp; dis[u] + 1 == dis[v]) &#123; int d = dfs(v, min(c[i], res)); c[i] -= d; c[i ^ 1] += d; res -= d; if(!res) return flow; &#125; &#125; return flow - res; &#125; int maxflow(int s, int t) &#123; S = s, T = t; int flow = 0; while(bfs()) &#123; memcpy(cur, head, sizeof head); flow += dfs(S, INF); &#125; return flow; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); int t = 5 * n * m + 1; rep(i, 1, n) rep(j, 1, m) tot += read(a[i][j]); rep(i, 1, n) rep(j, 1, m) tot += read(b[i][j]); rep(i, 1, n - 1) rep(j, 1, m) tot += read(samed_a[i][j]); rep(i, 1, n - 1) rep(j, 1, m) tot += read(samed_b[i][j]); rep(i, 1, n) rep(j, 1, m - 1) tot += read(samer_a[i][j]); rep(i, 1, n) rep(j, 1, m - 1) tot += read(samer_b[i][j]); rep(i, 1, n) rep(j, 1, m) &#123; int id = (i - 1) * m + j; ae(0, id, a[i][j]), ae(id, 0, 0); ae(id, t, b[i][j]), ae(t, id, 0); if(i != n) &#123; int idx = n * m + id; ae(0, idx, samed_a[i][j]), ae(idx, 0, 0); ae(idx, id, INF), ae(id, idx, 0); ae(idx, id + m, INF), ae(id + m, idx, 0); idx = 2 * n * m + id; ae(id, idx, INF), ae(idx, id, 0); ae(id + m, idx, INF), ae(idx, id + m, 0); ae(idx, t, samed_b[i][j]), ae(t, idx, 0); &#125; if(j != m) &#123; int idx = 3 * n * m + id; ae(0, idx, samer_a[i][j]), ae(idx, 0, 0); ae(idx, id, INF), ae(id, idx, 0); ae(idx, id + 1, INF), ae(id + 1, idx, 0); idx = 4 * n * m + id; ae(id, idx, INF), ae(idx, id, 0); ae(id + 1, idx, INF), ae(idx, id + 1, 0); ae(idx, t, samer_b[i][j]), ae(t, idx, 0); &#125; &#125; printf("%d\n", tot - dinic::maxflow(0, t)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ3674 可持久化并查集加强版]]></title>
      <url>%2F2017%2F06%2F09%2FBZOJ3674%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:n个点，3种操作，强制在线:&emsp;&emsp;1、连边(a, b)&emsp;&emsp;2、跳到第k次操作之后的状态&emsp;&emsp;3、询问(a, b) 是否连通 &emsp;&emsp;1和3操作是一个裸的并查集。&emsp;&emsp;2操作?暴力加边删边显然不可行。可持久化?&emsp;&emsp;我们发现并查集本质上就是一个数组。于是我们就是要将一个数组可持久化，支持查询每一个历史版本。&emsp;&emsp;我们可以用主席树来维护。主席树的叶子节点保存并查集数组，非叶子节点什么也不做。这样我们就保存下了每一个版本，只是数组中每一个元素的访问时间是$O(\log n)$的。&emsp;&emsp;需要注意的是不能只用路径压缩而不按秩合并。因为某一次路径压缩的复杂度是得不到保证的，我们不停退回执行某个卡路径压缩的操作就可以卡掉。事实上，使用了按秩合并之后，不用路径压缩复杂度也不会出现问题。&emsp;&emsp;代码中有一些细节，在注释中标出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a);template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c - '0'; isdigit(c = getchar()); (x *= 10) += c - '0'); if(flag) x = -x; return x;&#125;const int maxn = 200010;int n, m, lstans;namespace PSGT&#123;#define mid ((l + r) &gt;&gt; 1)#define lc l, mid#define rc mid + 1, r struct node &#123; int ls, rs; int f, rnk; node(): ls(0), rs(0), f(0), rnk(0) &#123; &#125; &#125; T[maxn * 2 * 18]; int rt[maxn], cur; void creat(int&amp; h, int l, int r) &#123; h = ++cur; if(l == r) &#123; T[h].f = l; return; &#125; creat(T[h].ls, lc); creat(T[h].rs, rc); &#125; void update(int&amp; h, int l, int r, int pos, int x) // 新建版本;查找位置pos与修改值x均为真实节点编号 &#123; T[++cur] = T[h]; h = cur; if(l == r) &#123; T[h].f = x; return; &#125; if(pos &lt;= mid) update(T[h].ls, lc, pos, x); else update(T[h].rs, rc, pos, x); &#125; void addrnk(int h, int l, int r, int pos) // 无需新建版本 &#123; if(l == r) &#123; ++T[h].rnk; return; &#125; if(pos &lt;= mid) addrnk(T[h].ls, lc, pos); else addrnk(T[h].rs, rc, pos); &#125; int query(int h, int l, int r, int x) &#123; if(l == r) return h; if(x &lt;= mid) return query(T[h].ls, lc, x); else return query(T[h].rs, rc, x); &#125;&#125;using namespace PSGT;int getf(int h, int v) // 返回真实节点在线段树上对应节点&#123; int p = query(h, 1, n, v); if(v == T[p].f) return p; return getf(h, T[p].f);&#125;void merge(int a, int b, int h)&#123; a = getf(rt[h], a), b = getf(rt[h], b); if(T[a].f != T[b].f) // T[a].f == 真实a编号, T[b].f == 真实b编号 &#123; if(T[a].rnk &gt; T[b].rnk) swap(a, b); update(rt[h], 1, n, T[a].f, T[b].f); if(T[a].rnk == T[b].rnk) addrnk(rt[h], 1, n, T[b].f); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); creat(rt[0], 1, n); rep(i, 1, m) &#123; int op, a, b; read(op); if(op == 1) &#123; rt[i] = rt[i - 1]; read(a), read(b); a ^= lstans, b ^= lstans; merge(a, b, i); &#125; if(op == 2) read(a), a ^= lstans, rt[i] = rt[a]; if(op == 3) &#123; rt[i] = rt[i - 1]; read(a), read(b); a ^= lstans, b ^= lstans; lstans = (T[getf(rt[i], a)].f == T[getf(rt[i], b)].f ? 1 : 0); printf("%d\n", lstans); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UOJ261【NOIP2016】天天爱跑步]]></title>
      <url>%2F2017%2F05%2F25%2FUOJ261%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一棵$n$个点的树，每个点$i$有权值$w_i$，$m$条路径，对每个点i求出有多少条路径经过i且路径起点与$i$的距离为$w_i$。 &emsp;&emsp;最近清noip题目发现这道题还没有做。回头来看，这道题仍然给我不小的收获。&emsp;&emsp;我们将路径$(u, v)$拆成向上路径$(u, lca)$和向下路径$(lca, v)$。首先考虑向上的路径。&emsp;&emsp;一条向上的路径$(u, v)$对点i有贡献，当且仅当:&emsp;&emsp;1、u在i的子树中&emsp;&emsp;2、$dep[u] = dep[i] + w[i]$&emsp;&emsp;3、路径经过i，即不会在到达i之前结束。&emsp;&emsp;由于2条件中的$dep[i] + w[i]$只与i有关，$dep[u]$只与u有关，我们便有了如下做法:&emsp;&emsp;存储下以每个节点i作为起点的路径$(u, v)$的$dep[u]$值(这里就是$dep[i]$)，以每个节点i作为终点的路径$(u, v)$的$dep[u]$值。维护一个全局的桶，每当遍历到一个点i时:&emsp;&emsp;1、处理i的子树&emsp;&emsp;2、将以i为起点路径的$dep[u]$值加入桶。&emsp;&emsp;3、统计桶里值=$dep[i] + w[i]$的元素个数，更新$ans[i]$。&emsp;&emsp;4、将以i为终点路径的$dep[u]$值从桶里删去。&emsp;&emsp;这里本质上是将桶中+1/-1事件挂在每个点上，每到一个点时查询桶中对应位置的子树和。这个打正负标记求和的思想在线性结构和树结构上都有广泛运用，常常与差分一起出现。&emsp;&emsp;这里呢?我们发现我们通过这种办法求出来的元素可能并不全在i子树中，也包括了从其他子树出发的向上路径。我们可以在dfs进入i点时，记录一下当前的答案，处理完i子树之后，将现在的答案与刚刚进入i时的答案相减，就得到了真正的答案了。这就是差分思想的一次体现。&emsp;&emsp;对于向下的路径，我们发现条件变化了。重新考虑原路径。对于原路径$(u, v)$分出的向下路径$(lca, v)$，对i有贡献的条件是:$dep[u] - 2 \times dep[lca] = w[i] - dep[i]$。于是我们也可以仿照上面的做法，先把向下路径反过来变为向上路径，将左边式子的值放入桶里，用右边式子的值查询。但是这个桶可能会有负数下标，要注意一下。&emsp;&emsp;最后，我们发现对于一条完整的路径，lca可能会被算两次贡献。这在读入路径的时候就判断减掉即可。&emsp;&emsp;做了一些noip的题目，发现近两年的最难题目都出在树上，而且都与正负标记求和与树上差分联系起来。这一点要着实注意啊。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt; using namespace std; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define ms(a, b) memset(a, b, sizeof a)#define SZ(x) (int((x).size()))#define pb push_back template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 300010;int n, m;int head[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e;void ae(int x, int y) &#123; to[++e] = y; nxt[e] = head[x]; head[x] = e; &#125;int fa[maxn][20], dep[maxn], w[maxn];void dfs1(int u)&#123; rep(i, 1, 19) fa[u][i] = fa[fa[u][i - 1]][i - 1]; erep(i, u) if(v != fa[u][0]) &#123; fa[v][0] = u; dep[v] = dep[u] + 1; dfs1(v); &#125;&#125;int getlca(int u, int v)&#123; if(dep[u] &lt; dep[v]) swap(u, v); drep(i, 19, 0) if((1 &lt;&lt; i) &amp; (dep[u] - dep[v])) u = fa[u][i]; drep(i, 19, 0) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return u == v ? u : fa[u][0];&#125;vector&lt;int&gt; Begin[2][maxn], End[2][maxn];int cnt[2][maxn * 2], ans[maxn];void dfs2(int u)&#123; int last = cnt[0][dep[u] + w[u]] + cnt[1][w[u] - dep[u] + n]; erep(i, u) if(v != fa[u][0]) dfs2(v); rep(i, 0, SZ(Begin[0][u]) - 1) ++cnt[0][Begin[0][u][i]]; rep(i, 0, SZ(Begin[1][u]) - 1) ++cnt[1][Begin[1][u][i] + n]; ans[u] += cnt[0][dep[u] + w[u]] + cnt[1][w[u] - dep[u] + n] - last; rep(i, 0, SZ(End[0][u]) - 1) --cnt[0][End[0][u][i]]; rep(i, 0, SZ(End[1][u]) - 1) --cnt[1][End[1][u][i] + n];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); int u, v, lca; rep(i, 1, n - 1) read(u), read(v), ae(u, v), ae(v, u); rep(i, 1, n) read(w[i]); dfs1(1); rep(i, 1, m) &#123; read(u), read(v); lca = getlca(u, v); if(dep[u] - dep[lca] == w[lca]) --ans[lca]; Begin[0][u].pb(dep[u]); End[0][lca].pb(dep[u]); Begin[1][v].pb(dep[u]- 2 * dep[lca]); End[1][lca].pb(dep[u] - 2 * dep[lca]); &#125; dfs2(1); rep(i, 1, n) printf("%d ", ans[i]); puts(""); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ4552 排序]]></title>
      <url>%2F2017%2F05%2F22%2FBZOJ4552%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个1-n的全排列，进行m次局部排序(选定一个区间，升序或降序排序)，最后求第q位置上数字。 &emsp;&emsp;这道题有个咸鱼做法:二分数字，转化为01序列然后就很好办了。但是这样时间要多一个log而且不支持在线。&emsp;&emsp;而如果使用线段树合并的话，就可以不用最后求，而是随时求q位置数字了。&emsp;&emsp;对每个操作区间建立一棵权值线段树，并且记录当前顺序是升序还是降序，操作一个区间时，先找到包含该区间一部分的权值线段树，将两端多出去的地方割裂(要用到线段树分裂)，然后一个个合并起来。对于每个区间的开头我们用一个set存储，这样可以实现快速插入删除区间。&emsp;&emsp;注意分裂的时候没有下传l与r端点，所以k值等于左儿子size的时候就不要下传了，以免陷入死循环。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;set&gt;#include &lt;vector&gt; using namespace std; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a)#define pb push_back#define SZ(x) (int((x).size())) template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010;int n, m, a[maxn];set&lt;int&gt; S;set&lt;int&gt;::iterator it;int tp[maxn], End[maxn];namespace SGT&#123;#define mid ((l + r) &gt;&gt; 1)#define lc l, mid#define rc mid + 1, r struct node &#123; int ls, rs; int sz; node(): ls(0), rs(0), sz(0) &#123; &#125; &#125;T[maxn * 18 * 3]; int rt[maxn], cur; void pushup(int h) &#123; T[h].sz = T[T[h].ls].sz + T[T[h].rs].sz; &#125; void update(int&amp; h, int l, int r, int x) &#123; if(!h) h = ++cur; if(l == r) &#123; ++T[h].sz; return; &#125; if(x &lt;= mid) update(T[h].ls, lc, x); else update(T[h].rs, rc, x); pushup(h); &#125; void split(int h1, int&amp; h2, int k) &#123; h2 = ++cur; if(k &gt; T[T[h1].ls].sz) split(T[h1].rs, T[h2].rs, k - T[T[h1].ls].sz); else &#123; swap(T[h1].rs, T[h2].rs); if(k &lt; T[T[h1].ls].sz) split(T[h1].ls, T[h2].ls, k); &#125; T[h2].sz = T[h1].sz - k; T[h1].sz = k; &#125; void merge(int&amp; h1, int h2) &#123; if(!h2) return; if(!h1) &#123; h1 = h2; return; &#125; merge(T[h1].ls, T[h2].ls); merge(T[h1].rs, T[h2].rs); pushup(h1); &#125; int query(int h, int l, int r, int k) &#123; if(l == r) return l; if(k &gt; T[T[h].ls].sz) return query(T[h].rs, rc, k - T[T[h].ls].sz); else return query(T[h].ls, lc, k); &#125;&#125;using namespace SGT;void Split(int x, int pos)&#123; if(pos &gt;= End[x] || pos &lt; x) return; if(!tp[x]) split(rt[x], rt[pos + 1], pos - x + 1); else &#123; rt[pos + 1] = rt[x]; split(rt[pos + 1], rt[x], End[x] - pos); &#125; End[pos + 1] = End[x]; End[x] = pos; S.insert(pos + 1); tp[pos + 1] = tp[x];&#125;void Merge(int x, int y)&#123; S.erase(y); merge(rt[x], rt[y]); End[x] = End[y];&#125;int Query(int x, int k)&#123; k -= x - 1; if(!tp[x]) return query(rt[x], 1, n, k); else return query(rt[x], 1, n, (End[x] - x + 1) - k + 1);&#125;vector&lt;int&gt; tmp;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); rep(i, 1, n) &#123; read(a[i]); update(rt[i], 1, n, a[i]); S.insert(i); End[i] = i; &#125; while(m--) &#123; int op, l, r; read(op), read(l), read(r); it = S.upper_bound(l); --it; Split(*it, l - 1); it = S.upper_bound(r); --it; Split(*it, r); set&lt;int&gt;::iterator L, R; L = S.lower_bound(l); R = S.upper_bound(r); if(L != R) &#123; tmp.clear(); for(it = L, ++it; it != R; ++it) tmp.pb(*it); rep(i, 0, SZ(tmp) - 1) Merge(*L, tmp[i]); &#125; tp[*L] = op; &#125; int q; read(q); it = S.upper_bound(q); --it; printf("%d\n", Query(*it, q)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ3064 CPU监控]]></title>
      <url>%2F2017%2F05%2F22%2FBZOJ3064%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:维护一个序列，4个操作:&emsp;&emsp;1、区间加上x&emsp;&emsp;2、区间赋值为x&emsp;&emsp;3、询问区间最大值&emsp;&emsp;4、询问区间历史最大值 &emsp;&emsp;区间历史最值，涉及到多次add和set操作的先后顺序，不是个好办的东西。&emsp;&emsp;参考吉如一2016集训队论文，发现了一个巧妙的做法。&emsp;&emsp;支持add和set操作的线段树有一个性质:&emsp;&emsp;当一次set操作之后，在下一次节点pushdown之前，由于此时区间均为一个数，所以区间add操作可以全部视为区间set。&emsp;&emsp;所以我们只需要考虑第一次set之前的add标记达到过的最值maxadd和后面的set标记达到过的最值maxset。&emsp;&emsp;至此问题已经解决。&emsp;&emsp;程序有点长，在过程中始终要牢记第一次set之后的add全部变成set，不管何处都是一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt; using namespace std; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a) template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125; const int maxn = 100010, INF = 0x3f3f3f3f; int n, m; namespace SGT&#123;#define ls h &lt;&lt; 1#define rs h &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)#define lc l, mid#define rc mid + 1, r int Max[maxn * 3], PastMax[maxn * 3]; int add[maxn * 3], set[maxn * 3], pastadd[maxn * 3], pastset[maxn * 3]; void pushup(int h) &#123; Max[h] = max(Max[ls], Max[rs]); PastMax[h] = max(PastMax[ls], PastMax[rs]); &#125; void creat(int h, int l, int r) &#123; set[h] = pastset[h] = -INF; if(l == r) &#123; PastMax[h] = read(Max[h]); return; &#125; creat(ls, lc); creat(rs, rc); pushup(h); &#125; void pushdown(int h) &#123; if(pastadd[h]) &#123; chkmax(PastMax[ls], Max[ls] + pastadd[h]); if(pastset[ls] == -INF) chkmax(pastadd[ls], add[ls] + pastadd[h]); else chkmax(pastset[ls], set[ls] + pastadd[h]); chkmax(PastMax[rs], Max[rs] + pastadd[h]); if(pastset[rs] == -INF) chkmax(pastadd[rs], add[rs] + pastadd[h]); else chkmax(pastset[rs], set[rs] + pastadd[h]); pastadd[h] = 0; &#125; if(pastset[h] != -INF) &#123; chkmax(PastMax[ls], pastset[h]); chkmax(pastset[ls], pastset[h]); chkmax(PastMax[rs], pastset[h]); chkmax(pastset[rs], pastset[h]); pastset[h] = -INF; &#125; if(set[h] != -INF) &#123; Max[ls] = Max[rs] = set[h]; set[ls] = set[rs] = set[h]; add[ls] = add[rs] = 0; set[h] = -INF; &#125; if(add[h]) &#123; Max[ls] += add[h], Max[rs] += add[h]; if(pastset[ls] == -INF) add[ls] += add[h]; else set[ls] += add[h]; if(pastset[rs] == -INF) add[rs] += add[h]; else set[rs] += add[h]; add[h] = 0; &#125; &#125; void upd_add(int h, int l, int r, int L, int R, int x) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; Max[h] += x; chkmax(PastMax[h], Max[h]); if(pastset[h] == -INF) &#123; add[h] += x; chkmax(pastadd[h], add[h]); &#125; else &#123; set[h] += x; chkmax(pastset[h], set[h]); &#125; return; &#125; pushdown(h); if(L &lt;= mid) upd_add(ls, lc, L, R, x); if(R &gt; mid) upd_add(rs, rc, L, R, x); pushup(h); &#125; void upd_set(int h, int l, int r, int L, int R, int x) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; Max[h] = set[h] = x; add[h] = 0; chkmax(PastMax[h], Max[h]); chkmax(pastset[h], set[h]); return; &#125; pushdown(h); if(L &lt;= mid) upd_set(ls, lc, L, R, x); if(R &gt; mid) upd_set(rs, rc, L, R, x); pushup(h); &#125; int query(int h, int l, int r, int L, int R, bool op) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return op ? Max[h] : PastMax[h]; pushdown(h); int ret = -INF; if(L &lt;= mid) chkmax(ret, query(ls, lc, L, R, op)); if(R &gt; mid) chkmax(ret, query(rs, rc, L, R, op)); return ret; &#125;&#125;using namespace SGT; int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); creat(1, 1, n); read(m); while(m--) &#123; char op[2]; int l, r, w; scanf("%s", op); read(l), read(r); if(op[0] == 'P') read(w), upd_add(1, 1, n, l, r, w); else if(op[0] == 'C') read(w), upd_set(1, 1, n, l, r, w); else printf("%d\n", query(1, 1, n, l, r, op[0] == 'Q')); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UOJ164 V]]></title>
      <url>%2F2017%2F05%2F22%2FUOJ164%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:维护一个序列，5个操作:&emsp;&emsp;1、区间加x&emsp;&emsp;2、区间减x后对0取max&emsp;&emsp;3、区间覆盖成x&emsp;&emsp;4、询问单点值&emsp;&emsp;5、询问单点历史最大值 &emsp;&emsp;又是一眼线段树。但是同样也有新东西。&emsp;&emsp;首先，区间减x后对0取max这个操作看起来十分的棘手。还有就是历史最大值。&emsp;&emsp;但是这道题的好处是单点查询，也就是说我们的每个节点并不需要维护实际信息，而只需要维护lazy-tag。将初始信息记录在叶节点tag上，在询问单点时，将一路上的tag给pushdown下去，最后一个点的tag上的值就用来更新答案了。&emsp;&emsp;我们定义节点tag为一个二元组$(a, b)$&emsp;代表执行这个标记时，对于区间内的数，先加上a然后对b取max。&emsp;&emsp;那么操作1 2 3分别对应标记$(x, {- \infty})$ $(-x, 0)$ $({- \infty}, x)$&emsp;&emsp;如何pushdown这个标记?设下传的标记为$(A, B)$，直接将当前标记$(a, b)$更新为(a + A, \max(b + A, B))即可。&emsp;&emsp;在实际应用中由于数字可能爆-INF的下界，所以左边要对-INF取个max。&emsp;&emsp;如何维护历史标记?同样用一个二元组$(c, d)$，分别代表该节点在上次与这次pushdown之间的最大add值和最大取max值。pushdown的话，设下传的标记为$(C, D)$，当前历史标记更新为:(\max(c, a + C), \max(d, b + C, D))&emsp;&emsp;左侧同样要对-INF取max。注意到更新标记涉及到节点当前标记$(a, b)$，所以pushdown时先下传历史标记再下传当前标记。&emsp;&emsp;最后pushdown到叶子时，节点的$\max(a, b)$、$\max(c, d)$就分别为当前和历史的答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt; using namespace std; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define x first#define y second template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 500010;int n, m;typedef long long LL;const LL INF = 0x3f3f3f3f3f3f3f3fll;typedef pair&lt;LL, LL&gt; PLL;namespace SGT&#123;#define ls h &lt;&lt; 1#define rs h &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)#define lc l, mid#define rc mid + 1, r PLL T[maxn * 3], Past[maxn * 3]; void creat(int h, int l, int r) &#123; if(l == r) &#123; Past[h].x = Past[h].y = T[h].x = read(T[h].y); return; &#125; creat(ls, lc); creat(rs, rc); &#125; void pushdown(int h) &#123; chkmax(Past[ls].x, max(Past[h].x + T[ls].x, -INF)); chkmax(Past[ls].y, max(Past[h].y, Past[h].x + T[ls].y)); chkmax(Past[rs].x, max(Past[h].x + T[rs].x, -INF)); chkmax(Past[rs].y, max(Past[h].y, Past[h].x + T[rs].y)); T[ls] = mp(max(T[ls].x + T[h].x, -INF), max(T[ls].y + T[h].x, T[h].y)); T[rs] = mp(max(T[rs].x + T[h].x, -INF), max(T[rs].y + T[h].x, T[h].y)); T[h] = Past[h] = mp(0, 0); &#125; void update(int h, int l, int r, int L, int R, PLL w) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; T[h] = mp(max(T[h].x + w.x, -INF), max(T[h].y + w.x, w.y)); chkmax(Past[h].x, T[h].x); chkmax(Past[h].y, T[h].y); return; &#125; pushdown(h); if(L &lt;= mid) update(ls, lc, L, R, w); if(R &gt; mid) update(rs, rc, L, R, w); &#125; LL query(int h, int l, int r, int p, bool op) &#123; if(l == r) return op ? max(T[h].x, T[h].y) : max(Past[h].x, Past[h].y); pushdown(h); if(p &lt;= mid) return query(ls, lc, p, op); else return query(rs, rc, p, op); &#125;&#125;using namespace SGT;int main()&#123; freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout); read(n); read(m); creat(1, 1, n); while(m--) &#123; int op, l, r; LL w; read(op); if(op == 1) read(l), read(r), read(w), update(1, 1, n, l, r, mp(w, 0)); else if(op == 2) read(l), read(r), read(w), update(1, 1, n, l, r, mp(-w, 0)); else if(op == 3) read(l), read(r), read(w), update(1, 1, n, l, r, mp(-INF, w)); else read(l), printf("%lld\n", query(1, 1, n, l, op == 4)); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU5306 Gorgeous Sequence]]></title>
      <url>%2F2017%2F05%2F21%2FHDU5306%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:维护一个数列，三个操作:&emsp;&emsp;1、区间对一个数取min&emsp;&emsp;2、询问区间max&emsp;&emsp;3、询问区间sum &emsp;&emsp;这道题看着就是一个线段树。&emsp;&emsp;仔细观察发现，1操作似乎不是很好维护，如果要维护似乎只能暴力下传。(其实暴力下传也能够过)&emsp;&emsp;有什么更好的办法?&emsp;&emsp;参考吉如一2016集训队论文，发现虽然不能有更好的替代方法，但是可以进行优化，减少下传次数。&emsp;&emsp;维护最大值$max$与区间和$sum$之外，再维护次大值$second$，最大值出现次数$times$。&emsp;&emsp;每次区间对一个数$x$取min时:&emsp;&emsp;若区间$max &lt;= x$，忽略。&emsp;&emsp;区间$max &gt; x$ 但 $second &lt; x$，则$sum$减去$(max - x) \times times$，$max$变为$times$。&emsp;&emsp;$second &gt;= x$，没办法，暴力递归解决。&emsp;&emsp;但是这样好像会递归到不存在的区间呀怎么办?没关系。不存在的区间max与second均为0，到了就会返回回来。唯一带来的坑点就是数组要看到$maxn \times 8$!!!!!(神坑)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a) template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 1000010;typedef long long LL;namespace SGT&#123;#define ls h &lt;&lt; 1#define rs h &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)#define lc l, mid#define rc mid + 1, r LL T[maxn * 8], Max[maxn * 8], Times[maxn * 8], Second[maxn * 8]; LL min[maxn * 8]; void pushup(int h) &#123; T[h] = T[ls] + T[rs]; if(Max[ls] == Max[rs]) &#123; Max[h] = Max[ls]; Times[h] = Times[ls] + Times[rs]; Second[h] = std::max(Second[ls], Second[rs]); &#125; else &#123; if(Max[ls] &gt; Max[rs]) &#123; Max[h] = Max[ls]; Times[h] = Times[ls]; Second[h] = std::max(Second[ls], Max[rs]); &#125; else &#123; Max[h] = Max[rs]; Times[h] = Times[rs]; Second[h] = std::max(Second[rs], Max[ls]); &#125; &#125; &#125; void pushdown(int h) &#123; if(~min[h]) &#123; if(Max[ls] &gt; min[h]) &#123; T[ls] -= Times[ls] * (Max[ls] - min[h]); Max[ls] = min[ls] = min[h]; &#125; if(Max[rs] &gt; min[h]) &#123; T[rs] -= Times[rs] * (Max[rs] - min[h]); Max[rs] = min[rs] = min[h]; &#125; min[h] = -1; &#125; &#125; void creat(int h, int l, int r) &#123; min[h] = -1; if(l == r) &#123; Max[h] = read(T[h]); Second[h] = 0; Times[h] = 1; return; &#125; creat(ls, lc); creat(rs, rc); pushup(h); &#125; void update(int h, int l, int r, int L, int R, LL t) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; if(Max[h] &lt;= t) return; if(Second[h] &lt; t) &#123; T[h] -= Times[h] * (Max[h] - t); Max[h] = min[h] = t; &#125; else &#123; pushdown(h); update(ls, lc, L, R, t); update(rs, rc, L, R, t); pushup(h); &#125; return; &#125; pushdown(h); if(L &lt;= mid) update(ls, lc, L, R, t); if(R &gt; mid) update(rs, rc, L, R, t); pushup(h); &#125; LL qry_max(int h, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return Max[h]; pushdown(h); LL ret = 0; if(L &lt;= mid) chkmax(ret, qry_max(ls, lc, L, R)); if(R &gt; mid) chkmax(ret, qry_max(rs, rc, L, R)); return ret; &#125; LL qry_sum(int h, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return T[h]; pushdown(h); LL ret = 0; if(L &lt;= mid) ret += qry_sum(ls, lc, L, R); if(R &gt; mid) ret += qry_sum(rs, rc, L, R); return ret; &#125;&#125;using namespace SGT;int n, m;int main()&#123; int _; read(_); while(_--) &#123; read(n); read(m); creat(1, 1, n); while(m--) &#123; int op, L, R; LL t; read(op); if(op == 0) read(L), read(R), read(t), update(1, 1, n, L, R, t); if(op == 1) read(L), read(R), printf("%lld\n", qry_max(1, 1, n, L, R)); if(op == 2) read(L), read(R), printf("%lld\n", qry_sum(1, 1, n, L, R)); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ2555 Substring]]></title>
      <url>%2F2017%2F05%2F15%2FBZOJ2555%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个字符串，两种操作，强制在线:&emsp;&emsp;1、在当前字符串后接上一个字符串&emsp;&emsp;2、查询某一串在当前字符串的出现次数 &emsp;&emsp;维护每一个子串的出现次数，很容易想到SAM维护right集合大小。在SAM上运行这个串，在next边形成的树结构中，到达节点为根的子树的节点个数就是答案。&emsp;&emsp;暴力做法自然就是每次新加入一个字符，沿着next边向上更新节点信息。鉴于这是一个树结构，我们考虑用动态树来加速。&emsp;&emsp;但是好像要维护子树大小?虽然这样可做，但是有没有更简洁的方法?我们注意到这道题是没有换根操作的，树本身的形态不会改变，于是我们可以类似与暴力，将子树大小当做信息记在节点上。每次连next边的时候cut、link一下改变树的形态，暴力更新信息变成打tag就好。由于节点信息是独立的，所以连pushup都不要。注意每次在复制、输出节点信息时别忘了relax一波。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt; using namespace std; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a) template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125; const int SIZE = 1500010, SIGMA = 26; int q, mask, ans; struct node&#123; node *p, *c[2]; bool rev; int val, add; node(): p(0), rev(0), val(0), add(0) &#123; c[0] = c[1] = 0; &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev ^= 1; &#125; if(add) &#123; rep(i, 0, 1) if(c[i]) &#123; c[i]-&gt;val += add; c[i]-&gt;add += add; &#125; add = 0; &#125; &#125; void rot() &#123; node* f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) u-&gt;splay(), u-&gt;setc(v, 1); splay(); &#125;&#125;nd[SIZE]; namespace LCT&#123; void cut(int x) &#123; node* u = nd + x; u-&gt;access(); u-&gt;c[0] = u-&gt;c[0]-&gt;p = NULL; &#125; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;p = v; &#125; void update(int x) &#123; node* u = nd + x; u-&gt;access(); ++u-&gt;val; ++u-&gt;add; &#125;&#125;using namespace LCT; namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) &#123; next[u] = 1; link(u, 1); &#125; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) &#123; next[u] = h; link(u, h); &#125; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; link(o, next[h]); next[h] = next[u] = o; cut(h); link(h, o); link(u, o); (nd + h)-&gt;relax(); (nd + o)-&gt;val = (nd + h)-&gt;val; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; update(u); &#125; int query(char* s) &#123; int h = 1; rep(i, 0, strlen(s) - 1) &#123; if(!ch[h][s[i] - 'A']) return 0; h = ch[h][s[i] - 'A']; &#125; return (nd + h)-&gt;relax(), (nd + h)-&gt;val; &#125;&#125;using namespace SAM; char op[10], s[SIZE &lt;&lt; 1]; void decode(char* s, int base)&#123; int len = strlen(s); rep(i, 0, len - 1) &#123; base = (base * 131 + i) % len; swap(s[i], s[base]); &#125;&#125; int main()&#123; init(); read(q); scanf("%s", s); rep(i, 0, strlen(s) - 1) extend(s[i] - 'A'); while(q--) &#123; scanf("%s%s", op, s); decode(s, mask); if(op[0] == 'A') rep(i, 0, strlen(s) - 1) extend(s[i] - 'A'); else &#123; ans = query(s); mask ^= ans; printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UOJ35 后缀排序]]></title>
      <url>%2F2017%2F05%2F15%2FUOJ35%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:造出一个字符串的后缀数组，将sa数组与height数组输出。 &emsp;&emsp;这道题当然是一道后缀数组的模板。但是为了更高的效率，我们不用倍增法，而是使用SAM造出后缀树，再用后缀树造出后缀数组。&emsp;&emsp;关于后缀树的资料可以去网上找，在此不赘述。我们唯一需要知道的是，后缀树每一条边对应的字符串首字符都是互不相同的，仅仅依靠首字符就可以区别从一个节点伸出的所有边。&emsp;&emsp;首先，由于原串的SAM的next链接就是反串的后缀树，于是我们将原串的反串插入SAM，这样造出的后缀树就是原串的后缀树了。但是这样造出的仅仅是只有点和边的空后缀树，我们需要在上面添加信息。&emsp;&emsp;我们对于每个节点记录一个pos——代表其中最长串(反串前缀)在原串后缀中对应的首字符位置，方便以后造sa数组。我们还需要维护一个right数组，这个数组并不代表right集合。对于每个插入字符时为接纳新子串产生的节点(而非分裂出来的节点)，其right值=自身max值。而对于分裂出来的节点，其right值=该轮新产生节点的max。&emsp;&emsp;在造后缀树的时候，节点本身的right值-其next节点的max值=后缀树中next节点到该节点边的首字符在反串中的位置。更进一步地，将反串起始位置到该位置的子串翻转，就是这条边对应的字符串。其实这一点不难理解，结合一下定义就很容易明白，这里不多说了。&emsp;&emsp;将反串中的位置对应到原串上，找到那个字符作为边的首字符，我们就可以区分每条边，也就可以按照字典序遍历后缀树，依照每个节点的pos造出后缀数组了。&emsp;&emsp;上代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = E[i].v; i; i = E[i].nxt, v = E[i].v)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, SIZE = maxn &lt;&lt; 2, SIGMA = 26;int sa[maxn], sa_cur, rnk[maxn], height[maxn];char s[maxn];int n;namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE], pos[SIZE], right[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c, int p) &#123; int u = New(Max[last] + 1), v = last; pos[u] = p; right[u] = Max[u]; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); right[o] = right[u]; memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125; namespace ST &#123; struct edge &#123; int u, v, w; int nxt; &#125;E[SIZE]; int head[SIZE], en; void ae(int i) &#123; E[i].nxt = head[E[i].u]; head[E[i].u] = i; &#125; void build_sa(int u) &#123; if(pos[u]) sa[++sa_cur] = pos[u]; erep(i, u) build_sa(v); &#125; int sum[SIGMA], t[SIZE]; void build_ST() &#123; rep(i, 2, cur) &#123; E[++en] = (edge) &#123; next[i], i, s[n - (right[i] - Max[next[i]]) + 1] - 'a', 0 &#125;; ++sum[E[en].w]; &#125; rep(i, 1, SIGMA - 1) sum[i] += sum[i - 1]; rep(i, 1, en) t[sum[E[i].w]--] = i; drep(i, en, 1) ae(t[i]); &#125; &#125; using namespace ST;&#125;using namespace SAM;void build_height()&#123; int j = 0; rep(i, 1, n) if(rnk[i] != n) &#123; while(s[i + j] == s[sa[rnk[i] + 1] + j]) ++j; height[rnk[i]] = j; if(j) --j; &#125;&#125;int main()&#123; init(); scanf("%s", s + 1); n = strlen(s + 1); drep(i, n, 1) extend(s[i] - 'a', i); build_ST(); build_sa(1); rep(i, 1, n) rnk[sa[i]] = i; build_height(); rep(i, 1, n) printf("%d ", sa[i]); puts(""); rep(i, 1, n - 1) printf("%d ", height[i]); puts(""); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UOJ207 共价大爷游长沙]]></title>
      <url>%2F2017%2F05%2F14%2FUOJ207%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 一棵树，四个操作:&emsp;&emsp;1、删边 + 加边&emsp;&emsp;2、加入点对(x, y)&emsp;&emsp;3、删除第x个加入的点对&emsp;&emsp;4、询问当前所有点对之间的路径是否均经过边(x, y) &emsp;&emsp;这道题是动态树维护虚边信息的好题。&emsp;&emsp;考察操作4，所有点对路径均经过边(x, y)，就代表着将x作为树根后，所有点对均有且只有一个点在y的子树中。(包括y)&emsp;&emsp;我们将每一条路径随机一个很大的权值，并异或到对应点对的两个点上。则x作为根并access(y)后，y的实子树中只有点x。那么所有路径有且只有一个点在y子树中-&gt;y及其虚子树异或和=所有路径异或和。当然以上成立的条件是随机出的权值没有重复，异或和也不能有重复的。在int范围内随机就可以避免这个问题了。&emsp;&emsp;维护一个所有路径异或和now和每个节点的信息，加入与删除路径点对时记得在总异或和与路径两端点权值中加上(清掉)该路径权值，异或一下就好。&emsp;&emsp;这道题需要维护子树和，由于是第一次练习，为了写得更模板化，我多使用了几个变量:&emsp;&emsp;val —&gt; 节点权值&emsp;&emsp;sum_chain —&gt; 节点实子树权值和(包括节点本身)&emsp;&emsp;val_tree —&gt; 节点虚子树权值和(不包括节点本身)&emsp;&emsp;sum_tree —&gt; 节点及其实子树所有节点的虚子树权值和(不包括实子树节点及本身)&emsp;&emsp;以上所有权值和在本题中均指异或和。&emsp;&emsp;前两项是平时维护的东西，后面多出来的两项是额外维护的东西。&emsp;&emsp;这些东西可以干很多事情,比如: sum_tree + sum_chain = 该节点为根的子树的和&emsp;&emsp;又比如，将加法换成异或，则val ^ val_tree 就是我们要找的节点及虚子树的异或和。&emsp;&emsp;在题目中，有些东西可以合在一起维护，具体问题具体分析。&emsp;&emsp;维护虚边信息的动态树在写法上面有改变，尤其是node中的access操作。要留心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define getchar getchar_unlockedtemplate&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 300010;struct node&#123; node *p, *c[2]; bool rev; int val_tree, val; int sum_tree, sum_chain; node(): p(0), rev(0), val_tree(0), val(0), sum_tree(0), sum_chain(0) &#123; ms(c, 0); &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; sum_tree = val_tree; sum_chain = val; rep(i, 0, 1) if(c[i]) &#123; sum_chain ^= c[i]-&gt;sum_chain; sum_tree ^= c[i]-&gt;sum_tree; &#125; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node *f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) &#123; u-&gt;splay(); if(u-&gt;c[1]) u-&gt;val_tree ^= u-&gt;c[1]-&gt;sum_tree ^ u-&gt;c[1]-&gt;sum_chain; if(v) u-&gt;val_tree ^= v-&gt;sum_tree ^ v-&gt;sum_chain; u-&gt;setc(v, 1), u-&gt;pushup(); &#125; splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn];int n, m, now;int a[maxm], cnt;pair&lt;int, int&gt; path[maxm];namespace LCT&#123; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v; v-&gt;val_tree ^= u-&gt;sum_tree ^ u-&gt;sum_chain; v-&gt;pushup(); &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; void change(int x, int y) &#123; node *u = nd + x; u-&gt;access(); u-&gt;val ^= y; u-&gt;pushup(); &#125; bool query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return (v-&gt;val ^ v-&gt;val_tree) == now; &#125;&#125;using namespace LCT;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif srand(time(0)); scanf("%*d"); read(n); read(m); int x, y; rep(i, 1, n - 1) read(x), read(y), link(x, y); while(m--) &#123; int op; read(op); if(op == 1) &#123; read(x); read(y); cut(x, y); read(x); read(y); link(x, y); &#125; if(op == 2) &#123; read(x); read(y); int Hash = rand(); now ^= Hash; change(x, Hash); change(y, Hash); path[++cnt] = mp(x, y); a[cnt] = Hash; &#125; if(op == 3) &#123; read(x); change(path[x].first, a[x]); change(path[x].second, a[x]); now ^= a[x]; &#125; if(op == 4) read(x), read(y), puts(query(x, y) ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SPOJ1812 LCS2]]></title>
      <url>%2F2017%2F05%2F09%2FSPOJ1812%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你n个串，求它们的LCS。 &emsp;&emsp;后缀系列的经典问题。&emsp;&emsp;这道题用后缀数组+二分当然可以做。将n个串连接成一个长串，只需要每次二分LCP，看是否有n个后缀LCP大于该值，又正好分属n个串就好。&emsp;&emsp;但这个复杂度显然是$O(n \log n)$的，在这里过不了。我们考虑用SAM解决这个问题。&emsp;&emsp;首先我们从两个串的情况入手: (SPOJ LCS正是两串LCS的题目)&emsp;&emsp;将第一个串$s_1$的SAM构建出来，然后在上面运行第二个串$s_2$。记录一个到当前位的LCS长度，记作len。如果当前到了第i位，节点u有$s_2[i]$的转移边,则走转移边，len长度+1。如果没有该转移边，由于next边上节点所包含的串均为当前点u包含串的后缀，所以沿着next边向前走，走到第一个有该转移边的节点v。根据节点的定义，一个节点有转移边，则其中所有串均可以通过这条转移边到另一个合法子串。于是我们只需要取最长的一个。即走过v的转移边，将len重新赋值为$Max[v] + 1$。如果走到根都没有转移边的话，就从根重新开始，并将len赋值为0。每走一步更新答案即可。&emsp;&emsp;如何处理多个串的情况?我们对于每个节点多记录两个值，一个代表所有串运行到当前点时的LCS值，一个代表当前串运行到当前点时的LCS，即上面的len。注:一个串可能被运行到一个点多次，记录最大值即可。要注意的是，在之前的双串LCS中，我们忽略了一个东西:当我们运行到一个点，即代表这个点包含的串在原串出现时，该节点通过next边连接的所有点，即该串的所有后缀也都在原串出现了，所以之前的点的len值也需要更新。在两个串的情况里，运行到一个点时，其代表串的后缀显然不会更优，并不用在意这一点。但是在多串中，我们需要考虑其他串的影响，就要基数排序排出节点间的拓扑序，按照其逆序更新所有节点的真正len值。运行完一个串后，将每个节点的所有串运行到当前点的LCS值对当前len取min即可。(如果没运行到则len=0，说明该节点代表的串不会参与答案更新)&emsp;&emsp;最后运行完所有串后，所有节点LCS的max值就是答案了。&emsp;&emsp;这道题卡时间，多清空几个数组都会T。不过错误算法(不基数排序)可以水过去。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, SIZE = maxn &lt;&lt; 2, SIGMA = 26;namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int LCS[SIZE], LEN[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125;&#125;using namespace SAM;char s[maxn];int n, ans;int sum[maxn], t[SIZE];int main()&#123; init(); scanf("%s", s); n = strlen(s); rep(i, 0, n - 1) extend(s[i] - 'a'); rep(i, 1, cur) LCS[i] = Max[i]; rep(i, 1, cur) ++sum[Max[i]]; rep(i, 1, n) sum[i] += sum[i - 1]; drep(i, cur, 1) t[sum[Max[i]]--] = i; while(~scanf("%s", s)) &#123; int h = 1, len = 0; ms(LEN, 0); rep(i, 0, strlen(s) - 1) &#123; if(ch[h][s[i] - 'a']) ++len, h = ch[h][s[i] - 'a']; else &#123; while(h &amp;&amp; !ch[h][s[i] - 'a']) h = next[h]; if(!h) h = 1, len = 0; else len = Max[h] + 1, h = ch[h][s[i] - 'a']; &#125; chkmax(LEN[h], len); &#125; drep(i, cur, 1) chkmax(LEN[next[t[i]]], LEN[t[i]]); rep(i, 1, cur) chkmin(LCS[i], LEN[i]); &#125; rep(i, 1, cur) chkmax(ans, LCS[i]); printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[POJ1509 Glass Beads]]></title>
      <url>%2F2017%2F05%2F07%2FPOJ1509%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你一个循环串(首尾相接)，求出使其字典序最小的起始位置。 &emsp;&emsp;后缀自动机(SAM)的第一道题。&emsp;&emsp;看后缀自动机有关的东西看了很久，差不多明白了一些。&emsp;&emsp;这道题其实本来有更加简单的暴力做法，不过就全当练习SAM了。&emsp;&emsp;首先将原串S扩展至两倍SS，这是循环串的惯用套路。&emsp;&emsp;接着将SAM增量构造出来，由于SAM包含了原串的所有子串，所以在SAM上，每次沿着字典序最小的边走，走$|S|$次，到达节点u一定包含要找的字典序最小的串。&emsp;&emsp;那么如何将其提取出来?也就是，如何在u表示的众多串中，找到那个串，并且知道其在原串中的起始位置呢?&emsp;&emsp;其实并不用找到那个串。注意到u表示的最长的串一定是从原串的开头到我们要找的串的末尾的。而根据SAM的性质，我们要找的串一定是最长串的后缀，且长度为n。于是$Max[u]-n+1$便是答案了。&emsp;&emsp;要注意一点:SAM中是否有某个节点是用其对应下标是否为0来判断的。所以SAM的start节点不能设为0。为了方便，设为1即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a)const int maxn = 10010, SIZE = (maxn &lt;&lt; 3), SIGMA = 26;template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;namespace SAM&#123; int cur, last; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void init() &#123; ms(next, 0); ms(Max, 0); ms(ch, 0); cur = last = 1; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125;&#125;using namespace SAM;char s[maxn];int n;int main()&#123; freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout); int _; read(_); while(_--) &#123; init(); scanf("%s", s); n = strlen(s); rep(i, 0, n - 1) extend(s[i] - 'a'); rep(i, 0, n - 1) extend(s[i] - 'a'); int h = 1; rep(i, 1, n) rep(c, 0, 25) if(ch[h][c]) &#123; h = ch[h][c]; break; &#125; printf("%d\n", Max[h] - n + 1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ4025 二分图]]></title>
      <url>%2F2017%2F05%2F04%2FBZOJ4025%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 给你一个图中每个点出现与消失的时刻，求在每一个时刻中该图是否为二分图。 &emsp;&emsp;这道题可以说是LCT维护动态生成树的集大成题。其中加入了二分图模型，对于以后很多的题目都具有启示意义。&emsp;&emsp;对于这道题，我们考虑维护以删除时间为关键字的最大生成树。对于整个图来说，就是一个最大生成森林。 &emsp;&emsp;在每一时刻，在生成森林中，对于每一条出现的边:&emsp;&emsp;如果该边两端不联通，则加入该边。&emsp;&emsp;如果该边两端联通，将该边连上后会出现一个环。&emsp;&emsp;如果这个环是奇环，那么将该环中删除时间最早(权值最小)的边删除，并加入标记集合，表示该边存在时，图不为二分图。&emsp;&emsp;具体实现的话，就是先将出现边与原路径中的最小边比较，如果比最小边要小，则直接判断是否为奇环加标记即可。&emsp;&emsp;如果比最小边要大，那么就删除最小边，连接上该边，将最小边拿去判断。 &emsp;&emsp;对于每一条删除的边:&emsp;&emsp;如果这条边在树上，直接cut。&emsp;&emsp;如果这条边在删除集合里，直接去掉。 &emsp;&emsp;每一个时刻，当且仅当集合内没有元素时，图为二分图。 &emsp;&emsp;维护生成树中最小/大边，我采用的是维护指针的方法。指针减去初指针就为实际下标了。&emsp;&emsp;判断是否为奇环，就维护LCT的size即可。注意边的size设为0。&emsp;&emsp;注意这道题的联通性不能用普通并查集，因为有cut操作。我直接暴力判断的联通性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define pb push_back#define SZ(x) (int((x).size()))template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x) &#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 200010, INF = 0x3f3f3f3f;struct node&#123; node *p, *c[2], *Min; bool rev, isdot; int val, sz; node(): p(0), Min(this), rev(0), val(INF) &#123; c[0] = c[1] = 0; &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; Min = this; rep(i, 0, 1) if(c[i] &amp;&amp; c[i]-&gt;Min-&gt;val &lt; Min-&gt;val) Min = c[i]-&gt;Min; sz = isdot; rep(i, 0, 1) if(c[i]) sz += c[i]-&gt;sz; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node* f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) u-&gt;splay(), u-&gt;setc(v, 1), u-&gt;pushup(); splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn + maxm];int n, m, t;namespace LCT&#123; bool check(int x, int y) &#123; node *u = nd + x, *v = nd + y; while(u-&gt;p) u = u-&gt;p; while(v-&gt;p) v = v-&gt;p; return u == v; &#125; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); u-&gt;p = v; &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; node* query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return v-&gt;Min; &#125;&#125;using namespace LCT;struct edge&#123; int u, v, w;&#125;E[maxm];vector&lt;int&gt; Add[maxn], Del[maxn];int cnt;bool inTree[maxm], inSet[maxm];int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); read(t); int st, ed; rep(i, 1, m) &#123; read(E[i].u), read(E[i].v), read(st), E[i].w = read(ed); Add[st].pb(i); Del[ed].pb(i); &#125; rep(i, 1, n) (nd + i)-&gt;isdot = (nd + i)-&gt;sz = 1; rep(i, 1, m) &#123; (nd + n + i)-&gt;val = E[i].w; (nd + n + i)-&gt;isdot = (nd + n + i)-&gt;sz = 0; &#125; rep(k, 0, t - 1) &#123; rep(i, 0, SZ(Add[k]) - 1) &#123; int j = Add[k][i]; if(E[j].u == E[j].v) &#123; inSet[j] = 1; ++cnt; continue; &#125; if(!check(E[j].u, E[j].v)) &#123; link(E[j].u, j + n); link(E[j].v, j + n); inTree[j] = 1; &#125; else &#123; node* o = query(E[j].u, E[j].v); int h = o - nd - n; if(E[j].w &gt; o-&gt;val) &#123; if((nd + E[j].v)-&gt;sz &amp; 1) inSet[h] = 1, ++cnt; cut(E[h].u, h + n); cut(E[h].v, h + n); link(E[j].u, j + n); link(E[j].v, j + n); inTree[h] = 0; inTree[j] = 1; &#125; else if((nd + E[j].v)-&gt;sz &amp; 1) inSet[j] = 1, ++cnt; &#125; &#125; rep(i, 0, SZ(Del[k]) - 1) &#123; int j = Del[k][i]; if(inTree[j]) inTree[j] = 0, cut(E[j].u, j + n), cut(E[j].v , j + n); if(inSet[j]) inSet[j] = 0, --cnt; &#125; puts(cnt ? "No" : "Yes"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World!]]></title>
      <url>%2F2017%2F04%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在新站的第一篇博客。多多关照。 1printf("hello world\n");]]></content>
    </entry>

    
  
  
</search>
