<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[BZOJ4025 二分图]]></title>
      <url>%2F2017%2F05%2F04%2FBZOJ4025%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 给你一个图中每个点出现与消失的时刻，求在每一个时刻中该图是否为二分图。 &emsp;&emsp;这道题可以说是LCT维护动态生成树的集大成题。其中加入了二分图模型，对于以后很多的题目都具有启示意义。&emsp;&emsp;对于这道题，我们考虑维护以删除时间为关键字的最大生成树。对于整个图来说，就是一个最大生成森林。 &emsp;&emsp;在每一时刻，在生成森林中，对于每一条出现的边:&emsp;&emsp;如果该边两端不联通，则加入该边。&emsp;&emsp;如果该边两端联通，将该边连上后会出现一个环。&emsp;&emsp;如果这个环是奇环，那么将该环中删除时间最早(权值最小)的边删除，并加入标记集合，表示该边存在时，图不为二分图。&emsp;&emsp;具体实现的话，就是先将出现边与原路径中的最小边比较，如果比最小边要小，则直接判断是否为奇环加标记即可。&emsp;&emsp;如果比最小边要大，那么就删除最小边，连接上该边，将最小边拿去判断。 &emsp;&emsp;对于每一条删除的边:&emsp;&emsp;如果这条边在树上，直接cut。&emsp;&emsp;如果这条边在删除集合里，直接去掉。 &emsp;&emsp;每一个时刻，当且仅当集合内没有元素时，图为二分图。 &emsp;&emsp;维护生成树中最小/大边，我采用的是维护指针的方法。指针减去初指针就为实际下标了。&emsp;&emsp;判断是否为奇环，就维护LCT的size即可。注意边的size设为0。&emsp;&emsp;注意这道题的联通性不能用普通并查集，因为有cut操作。我直接暴力判断的联通性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define pb push_back#define SZ(x) (int((x).size()))template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x) &#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 200010, INF = 0x3f3f3f3f;struct node&#123; node *p, *c[2], *Min; bool rev, isdot; int val, sz; node(): p(0), Min(this), rev(0), val(INF) &#123; c[0] = c[1] = 0; &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; Min = this; rep(i, 0, 1) if(c[i] &amp;&amp; c[i]-&gt;Min-&gt;val &lt; Min-&gt;val) Min = c[i]-&gt;Min; sz = isdot; rep(i, 0, 1) if(c[i]) sz += c[i]-&gt;sz; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node* f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) u-&gt;splay(), u-&gt;setc(v, 1), u-&gt;pushup(); splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn + maxm];int n, m, t;namespace LCT&#123; bool check(int x, int y) &#123; node *u = nd + x, *v = nd + y; while(u-&gt;p) u = u-&gt;p; while(v-&gt;p) v = v-&gt;p; return u == v; &#125; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); u-&gt;p = v; &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; node* query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return v-&gt;Min; &#125;&#125;using namespace LCT;struct edge&#123; int u, v, w;&#125;E[maxm];vector&lt;int&gt; Add[maxn], Del[maxn];int cnt;bool inTree[maxm], inSet[maxm];int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); read(t); int st, ed; rep(i, 1, m) &#123; read(E[i].u), read(E[i].v), read(st), E[i].w = read(ed); Add[st].pb(i); Del[ed].pb(i); &#125; rep(i, 1, n) (nd + i)-&gt;isdot = (nd + i)-&gt;sz = 1; rep(i, 1, m) &#123; (nd + n + i)-&gt;val = E[i].w; (nd + n + i)-&gt;isdot = (nd + n + i)-&gt;sz = 0; &#125; rep(k, 0, t - 1) &#123; rep(i, 0, SZ(Add[k]) - 1) &#123; int j = Add[k][i]; if(E[j].u == E[j].v) &#123; inSet[j] = 1; ++cnt; continue; &#125; if(!check(E[j].u, E[j].v)) &#123; link(E[j].u, j + n); link(E[j].v, j + n); inTree[j] = 1; &#125; else &#123; node* o = query(E[j].u, E[j].v); int h = o - nd - n; if(E[j].w &gt; o-&gt;val) &#123; if((nd + E[j].v)-&gt;sz &amp; 1) inSet[h] = 1, ++cnt; cut(E[h].u, h + n); cut(E[h].v, h + n); link(E[j].u, j + n); link(E[j].v, j + n); inTree[h] = 0; inTree[j] = 1; &#125; else if((nd + E[j].v)-&gt;sz &amp; 1) inSet[j] = 1, ++cnt; &#125; &#125; rep(i, 0, SZ(Del[k]) - 1) &#123; int j = Del[k][i]; if(inTree[j]) inTree[j] = 0, cut(E[j].u, j + n), cut(E[j].v , j + n); if(inSet[j]) inSet[j] = 0, --cnt; &#125; puts(cnt ? "No" : "Yes"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World!]]></title>
      <url>%2F2017%2F04%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在新站的第一篇博客。多多关照。 1printf("hello world\n");]]></content>
    </entry>

    
  
  
</search>
