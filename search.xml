<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[UOJ207]]></title>
      <url>%2F2017%2F05%2F14%2FUOJ207%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 一棵树，四个操作:&emsp;&emsp;1、删边 + 加边&emsp;&emsp;2、加入点对(x, y)&emsp;&emsp;3、删除第x个加入的点对&emsp;&emsp;4、询问当前所有点对之间的路径是否均经过边(x, y) &emsp;&emsp;这道题是动态树维护虚边信息的好题。&emsp;&emsp;考察操作4，所有点对路径均经过边(x, y)，就代表着将x作为树根后，所有点对均有且只有一个点在y的子树中。(包括y)&emsp;&emsp;我们将每一条路径随机一个很大的权值，并异或到对应点对的两个点上。则x作为根并access(y)后，y的实子树中只有点x。那么所有路径有且只有一个点在y子树中-&gt;y及其虚子树异或和=所有路径异或和。当然以上成立的条件是随机出的权值没有重复，异或和也不能有重复的。在int范围内随机就可以避免这个问题了。&emsp;&emsp;维护一个所有路径异或和now和每个节点的信息，加入与删除路径点对时记得在总异或和与路径两端点权值中加上(清掉)该路径权值，异或一下就好。&emsp;&emsp;这道题需要维护子树和，由于是第一次练习，为了写得更模板化，我多使用了几个变量:&emsp;&emsp;val –&gt; 节点权值&emsp;&emsp;sum_chain –&gt; 节点实子树权值和(包括节点本身)&emsp;&emsp;val_tree –&gt; 节点虚子树权值和(不包括节点本身)&emsp;&emsp;sum_tree –&gt; 节点及其实子树所有节点的虚子树权值和(不包括实子树节点及本身)&emsp;&emsp;以上所有权值和在本题中均指异或和。&emsp;&emsp;前两项是平时维护的东西，后面多出来的两项是额外维护的东西。&emsp;&emsp;这些东西可以干很多事情,比如: sum_tree + sum_chain = 该节点为根的子树的和&emsp;&emsp;又比如，将加法换成异或，则val ^ val_tree 就是我们要找的节点及虚子树的异或和。&emsp;&emsp;在题目中，有些东西可以合在一起维护，具体问题具体分析。&emsp;&emsp;维护虚边信息的动态树在写法上面有改变，尤其是node中的access操作。要留心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define getchar getchar_unlockedtemplate&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 300010;struct node&#123; node *p, *c[2]; bool rev; int val_tree, val; int sum_tree, sum_chain; node(): p(0), rev(0), val_tree(0), val(0), sum_tree(0), sum_chain(0) &#123; ms(c, 0); &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; sum_tree = val_tree; sum_chain = val; rep(i, 0, 1) if(c[i]) &#123; sum_chain ^= c[i]-&gt;sum_chain; sum_tree ^= c[i]-&gt;sum_tree; &#125; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node *f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) &#123; u-&gt;splay(); if(u-&gt;c[1]) u-&gt;val_tree ^= u-&gt;c[1]-&gt;sum_tree ^ u-&gt;c[1]-&gt;sum_chain; if(v) u-&gt;val_tree ^= v-&gt;sum_tree ^ v-&gt;sum_chain; u-&gt;setc(v, 1), u-&gt;pushup(); &#125; splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn];int n, m, now;int a[maxm], cnt;pair&lt;int, int&gt; path[maxm];namespace LCT&#123; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v; v-&gt;val_tree ^= u-&gt;sum_tree ^ u-&gt;sum_chain; v-&gt;pushup(); &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; void change(int x, int y) &#123; node *u = nd + x; u-&gt;access(); u-&gt;val ^= y; u-&gt;pushup(); &#125; bool query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return (v-&gt;val ^ v-&gt;val_tree) == now; &#125;&#125;using namespace LCT;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif srand(time(0)); scanf("%*d"); read(n); read(m); int x, y; rep(i, 1, n - 1) read(x), read(y), link(x, y); while(m--) &#123; int op; read(op); if(op == 1) &#123; read(x); read(y); cut(x, y); read(x); read(y); link(x, y); &#125; if(op == 2) &#123; read(x); read(y); int Hash = rand(); now ^= Hash; change(x, Hash); change(y, Hash); path[++cnt] = mp(x, y); a[cnt] = Hash; &#125; if(op == 3) &#123; read(x); change(path[x].first, a[x]); change(path[x].second, a[x]); now ^= a[x]; &#125; if(op == 4) read(x), read(y), puts(query(x, y) ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SPOJ1812 LCS2]]></title>
      <url>%2F2017%2F05%2F09%2FSPOJ1812%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你n个串，求它们的LCS。 &emsp;&emsp;后缀系列的经典问题。&emsp;&emsp;这道题用后缀数组+二分当然可以做。将n个串连接成一个长串，只需要每次二分LCP，看是否有n个后缀LCP大于该值，又正好分属n个串就好。&emsp;&emsp;但这个复杂度显然是$O(n \log n)$的，在这里过不了。我们考虑用SAM解决这个问题。&emsp;&emsp;首先我们从两个串的情况入手: (SPOJ LCS正是两串LCS的题目)&emsp;&emsp;将第一个串$s_1$的SAM构建出来，然后在上面运行第二个串$s_2$。记录一个到当前位的LCS长度，记作len。如果当前到了第i位，节点u有$s_2[i]$的转移边,则走转移边，len长度+1。如果没有该转移边，由于next边上节点所包含的串均为当前点u包含串的后缀，所以沿着next边向前走，走到第一个有该转移边的节点v。根据节点的定义，一个节点有转移边，则其中所有串均可以通过这条转移边到另一个合法子串。于是我们只需要取最长的一个。即走过v的转移边，将len重新赋值为$Max[v] + 1$。如果走到根都没有转移边的话，就从根重新开始，并将len赋值为0。每走一步更新答案即可。&emsp;&emsp;如何处理多个串的情况?我们对于每个节点多记录两个值，一个代表所有串运行到当前点时的LCS值，一个代表当前串运行到当前点时的LCS，即上面的len。注:一个串可能被运行到一个点多次，记录最大值即可。要注意的是，在之前的双串LCS中，我们忽略了一个东西:当我们运行到一个点，即代表这个点包含的串在原串出现时，该节点通过next边连接的所有点，即该串的所有后缀也都在原串出现了，所以之前的点的len值也需要更新。在两个串的情况里，运行到一个点时，其代表串的后缀显然不会更优，并不用在意这一点。但是在多串中，我们需要考虑其他串的影响，就要基数排序排出节点间的拓扑序，按照其逆序更新所有节点的真正len值。运行完一个串后，将每个节点的所有串运行到当前点的LCS值对当前len取min即可。(如果没运行到则len=0，说明该节点代表的串不会参与答案更新)&emsp;&emsp;最后运行完所有串后，所有节点LCS的max值就是答案了。&emsp;&emsp;这道题卡时间，多清空几个数组都会T。不过错误算法(不基数排序)可以水过去。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, SIZE = maxn &lt;&lt; 2, SIGMA = 26;namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int LCS[SIZE], LEN[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125;&#125;using namespace SAM;char s[maxn];int n, ans;int sum[maxn], t[SIZE];int main()&#123; init(); scanf("%s", s); n = strlen(s); rep(i, 0, n - 1) extend(s[i] - 'a'); rep(i, 1, cur) LCS[i] = Max[i]; rep(i, 1, cur) ++sum[Max[i]]; rep(i, 1, n) sum[i] += sum[i - 1]; drep(i, cur, 1) t[sum[Max[i]]--] = i; while(~scanf("%s", s)) &#123; int h = 1, len = 0; ms(LEN, 0); rep(i, 0, strlen(s) - 1) &#123; if(ch[h][s[i] - 'a']) ++len, h = ch[h][s[i] - 'a']; else &#123; while(h &amp;&amp; !ch[h][s[i] - 'a']) h = next[h]; if(!h) h = 1, len = 0; else len = Max[h] + 1, h = ch[h][s[i] - 'a']; &#125; chkmax(LEN[h], len); &#125; drep(i, cur, 1) chkmax(LEN[next[t[i]]], LEN[t[i]]); rep(i, 1, cur) chkmin(LCS[i], LEN[i]); &#125; rep(i, 1, cur) chkmax(ans, LCS[i]); printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[POJ1509 Glass Beads]]></title>
      <url>%2F2017%2F05%2F07%2FPOJ1509%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你一个循环串(首尾相接)，求出使其字典序最小的起始位置。 &emsp;&emsp;后缀自动机(SAM)的第一道题。&emsp;&emsp;看后缀自动机有关的东西看了很久，差不多明白了一些。&emsp;&emsp;这道题其实本来有更加简单的暴力做法，不过就全当练习SAM了。&emsp;&emsp;首先将原串S扩展至两倍SS，这是循环串的惯用套路。&emsp;&emsp;接着将SAM增量构造出来，由于SAM包含了原串的所有子串，所以在SAM上，每次沿着字典序最小的边走，走$|S|$次，到达节点u一定包含要找的字典序最小的串。&emsp;&emsp;那么如何将其提取出来?也就是，如何在u表示的众多串中，找到那个串，并且知道其在原串中的起始位置呢?&emsp;&emsp;其实并不用找到那个串。注意到u表示的最长的串一定是从原串的开头到我们要找的串的末尾的。而根据SAM的性质，我们要找的串一定是最长串的后缀，且长度为n。于是$Max[u]-n+1$便是答案了。&emsp;&emsp;要注意一点:SAM中是否有某个节点是用其对应下标是否为0来判断的。所以SAM的start节点不能设为0。为了方便，设为1即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a)const int maxn = 10010, SIZE = (maxn &lt;&lt; 3), SIGMA = 26;template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;namespace SAM&#123; int cur, last; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void init() &#123; ms(next, 0); ms(Max, 0); ms(ch, 0); cur = last = 1; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125;&#125;using namespace SAM;char s[maxn];int n;int main()&#123; freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout); int _; read(_); while(_--) &#123; init(); scanf("%s", s); n = strlen(s); rep(i, 0, n - 1) extend(s[i] - 'a'); rep(i, 0, n - 1) extend(s[i] - 'a'); int h = 1; rep(i, 1, n) rep(c, 0, 25) if(ch[h][c]) &#123; h = ch[h][c]; break; &#125; printf("%d\n", Max[h] - n + 1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ4025 二分图]]></title>
      <url>%2F2017%2F05%2F04%2FBZOJ4025%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 给你一个图中每个点出现与消失的时刻，求在每一个时刻中该图是否为二分图。 &emsp;&emsp;这道题可以说是LCT维护动态生成树的集大成题。其中加入了二分图模型，对于以后很多的题目都具有启示意义。&emsp;&emsp;对于这道题，我们考虑维护以删除时间为关键字的最大生成树。对于整个图来说，就是一个最大生成森林。 &emsp;&emsp;在每一时刻，在生成森林中，对于每一条出现的边:&emsp;&emsp;如果该边两端不联通，则加入该边。&emsp;&emsp;如果该边两端联通，将该边连上后会出现一个环。&emsp;&emsp;如果这个环是奇环，那么将该环中删除时间最早(权值最小)的边删除，并加入标记集合，表示该边存在时，图不为二分图。&emsp;&emsp;具体实现的话，就是先将出现边与原路径中的最小边比较，如果比最小边要小，则直接判断是否为奇环加标记即可。&emsp;&emsp;如果比最小边要大，那么就删除最小边，连接上该边，将最小边拿去判断。 &emsp;&emsp;对于每一条删除的边:&emsp;&emsp;如果这条边在树上，直接cut。&emsp;&emsp;如果这条边在删除集合里，直接去掉。 &emsp;&emsp;每一个时刻，当且仅当集合内没有元素时，图为二分图。 &emsp;&emsp;维护生成树中最小/大边，我采用的是维护指针的方法。指针减去初指针就为实际下标了。&emsp;&emsp;判断是否为奇环，就维护LCT的size即可。注意边的size设为0。&emsp;&emsp;注意这道题的联通性不能用普通并查集，因为有cut操作。我直接暴力判断的联通性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define pb push_back#define SZ(x) (int((x).size()))template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x) &#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 200010, INF = 0x3f3f3f3f;struct node&#123; node *p, *c[2], *Min; bool rev, isdot; int val, sz; node(): p(0), Min(this), rev(0), val(INF) &#123; c[0] = c[1] = 0; &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; Min = this; rep(i, 0, 1) if(c[i] &amp;&amp; c[i]-&gt;Min-&gt;val &lt; Min-&gt;val) Min = c[i]-&gt;Min; sz = isdot; rep(i, 0, 1) if(c[i]) sz += c[i]-&gt;sz; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node* f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) u-&gt;splay(), u-&gt;setc(v, 1), u-&gt;pushup(); splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn + maxm];int n, m, t;namespace LCT&#123; bool check(int x, int y) &#123; node *u = nd + x, *v = nd + y; while(u-&gt;p) u = u-&gt;p; while(v-&gt;p) v = v-&gt;p; return u == v; &#125; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); u-&gt;p = v; &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; node* query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return v-&gt;Min; &#125;&#125;using namespace LCT;struct edge&#123; int u, v, w;&#125;E[maxm];vector&lt;int&gt; Add[maxn], Del[maxn];int cnt;bool inTree[maxm], inSet[maxm];int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); read(t); int st, ed; rep(i, 1, m) &#123; read(E[i].u), read(E[i].v), read(st), E[i].w = read(ed); Add[st].pb(i); Del[ed].pb(i); &#125; rep(i, 1, n) (nd + i)-&gt;isdot = (nd + i)-&gt;sz = 1; rep(i, 1, m) &#123; (nd + n + i)-&gt;val = E[i].w; (nd + n + i)-&gt;isdot = (nd + n + i)-&gt;sz = 0; &#125; rep(k, 0, t - 1) &#123; rep(i, 0, SZ(Add[k]) - 1) &#123; int j = Add[k][i]; if(E[j].u == E[j].v) &#123; inSet[j] = 1; ++cnt; continue; &#125; if(!check(E[j].u, E[j].v)) &#123; link(E[j].u, j + n); link(E[j].v, j + n); inTree[j] = 1; &#125; else &#123; node* o = query(E[j].u, E[j].v); int h = o - nd - n; if(E[j].w &gt; o-&gt;val) &#123; if((nd + E[j].v)-&gt;sz &amp; 1) inSet[h] = 1, ++cnt; cut(E[h].u, h + n); cut(E[h].v, h + n); link(E[j].u, j + n); link(E[j].v, j + n); inTree[h] = 0; inTree[j] = 1; &#125; else if((nd + E[j].v)-&gt;sz &amp; 1) inSet[j] = 1, ++cnt; &#125; &#125; rep(i, 0, SZ(Del[k]) - 1) &#123; int j = Del[k][i]; if(inTree[j]) inTree[j] = 0, cut(E[j].u, j + n), cut(E[j].v , j + n); if(inSet[j]) inSet[j] = 0, --cnt; &#125; puts(cnt ? "No" : "Yes"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World!]]></title>
      <url>%2F2017%2F04%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在新站的第一篇博客。多多关照。 1printf("hello world\n");]]></content>
    </entry>

    
  
  
</search>
