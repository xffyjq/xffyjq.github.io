<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[BZOJ2555 Substring]]></title>
      <url>%2F2017%2F05%2F15%2FBZOJ2555%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:一个字符串，两种操作，强制在线:&emsp;&emsp;1、在当前字符串后接上一个字符串&emsp;&emsp;2、查询某一串在当前字符串的出现次数 &emsp;&emsp;维护每一个子串的出现次数，很容易想到SAM维护right集合大小。在SAM上运行这个串，在next边形成的树结构中，到达节点为根的子树的节点个数就是答案。&emsp;&emsp;暴力做法自然就是每次新加入一个字符，沿着next边向上更新节点信息。鉴于这是一个树结构，我们考虑用动态树来加速。&emsp;&emsp;但是好像要维护子树大小?虽然这样可做，但是有没有更简洁的方法?我们注意到这道题是没有换根操作的，树本身的形态不会改变，于是我们可以类似与暴力，将子树大小当做信息记在节点上。每次连next边的时候cut、link一下改变树的形态，暴力更新信息变成打tag就好。由于节点信息是独立的，所以连pushup都不要。注意每次在复制、输出节点信息时别忘了relax一波。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt; using namespace std; #define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a) template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125; template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125; const int SIZE = 1500010, SIGMA = 26; int q, mask, ans; struct node&#123; node *p, *c[2]; bool rev; int val, add; node(): p(0), rev(0), val(0), add(0) &#123; c[0] = c[1] = 0; &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev ^= 1; &#125; if(add) &#123; rep(i, 0, 1) if(c[i]) &#123; c[i]-&gt;val += add; c[i]-&gt;add += add; &#125; add = 0; &#125; &#125; void rot() &#123; node* f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) u-&gt;splay(), u-&gt;setc(v, 1); splay(); &#125;&#125;nd[SIZE]; namespace LCT&#123; void cut(int x) &#123; node* u = nd + x; u-&gt;access(); u-&gt;c[0] = u-&gt;c[0]-&gt;p = NULL; &#125; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;p = v; &#125; void update(int x) &#123; node* u = nd + x; u-&gt;access(); ++u-&gt;val; ++u-&gt;add; &#125;&#125;using namespace LCT; namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) &#123; next[u] = 1; link(u, 1); &#125; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) &#123; next[u] = h; link(u, h); &#125; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; link(o, next[h]); next[h] = next[u] = o; cut(h); link(h, o); link(u, o); (nd + h)-&gt;relax(); (nd + o)-&gt;val = (nd + h)-&gt;val; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; update(u); &#125; int query(char* s) &#123; int h = 1; rep(i, 0, strlen(s) - 1) &#123; if(!ch[h][s[i] - 'A']) return 0; h = ch[h][s[i] - 'A']; &#125; return (nd + h)-&gt;relax(), (nd + h)-&gt;val; &#125;&#125;using namespace SAM; char op[10], s[SIZE &lt;&lt; 1]; void decode(char* s, int base)&#123; int len = strlen(s); rep(i, 0, len - 1) &#123; base = (base * 131 + i) % len; swap(s[i], s[base]); &#125;&#125; int main()&#123; init(); read(q); scanf("%s", s); rep(i, 0, strlen(s) - 1) extend(s[i] - 'A'); while(q--) &#123; scanf("%s%s", op, s); decode(s, mask); if(op[0] == 'A') rep(i, 0, strlen(s) - 1) extend(s[i] - 'A'); else &#123; ans = query(s); mask ^= ans; printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UOJ35 后缀排序]]></title>
      <url>%2F2017%2F05%2F15%2FUOJ35%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:造出一个字符串的后缀数组，将sa数组与height数组输出。 &emsp;&emsp;这道题当然是一道后缀数组的模板。但是为了更高的效率，我们不用倍增法，而是使用SAM造出后缀树，再用后缀树造出后缀数组。&emsp;&emsp;关于后缀树的资料可以去网上找，在此不赘述。我们唯一需要知道的是，后缀树每一条边对应的字符串首字符都是互不相同的，仅仅依靠首字符就可以区别从一个节点伸出的所有边。&emsp;&emsp;首先，由于原串的SAM的next链接就是反串的后缀树，于是我们将原串的反串插入SAM，这样造出的后缀树就是原串的后缀树了。但是这样造出的仅仅是只有点和边的空后缀树，我们需要在上面添加信息。&emsp;&emsp;我们对于每个节点记录一个pos——代表其中最长串(反串前缀)在原串后缀中对应的首字符位置，方便以后造sa数组。我们还需要维护一个right数组，这个数组并不代表right集合。对于每个插入字符时为接纳新子串产生的节点(而非分裂出来的节点)，其right值=自身max值。而对于分裂出来的节点，其right值=该轮新产生节点的max。&emsp;&emsp;在造后缀树的时候，节点本身的right值-其next节点的max值=后缀树中next节点到该节点边的首字符在反串中的位置。更进一步地，将反串起始位置到该位置的子串翻转，就是这条边对应的字符串。其实这一点不难理解，结合一下定义就很容易明白，这里不多说了。&emsp;&emsp;将反串中的位置对应到原串上，找到那个字符作为边的首字符，我们就可以区分每条边，也就可以按照字典序遍历后缀树，依照每个节点的pos造出后缀数组了。&emsp;&emsp;上代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define erep(i, u) for(int i = head[u], v = E[i].v; i; i = E[i].nxt, v = E[i].v)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, SIZE = maxn &lt;&lt; 2, SIGMA = 26;int sa[maxn], sa_cur, rnk[maxn], height[maxn];char s[maxn];int n;namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE], pos[SIZE], right[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c, int p) &#123; int u = New(Max[last] + 1), v = last; pos[u] = p; right[u] = Max[u]; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); right[o] = right[u]; memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125; namespace ST &#123; struct edge &#123; int u, v, w; int nxt; &#125;E[SIZE]; int head[SIZE], en; void ae(int i) &#123; E[i].nxt = head[E[i].u]; head[E[i].u] = i; &#125; void build_sa(int u) &#123; if(pos[u]) sa[++sa_cur] = pos[u]; erep(i, u) build_sa(v); &#125; int sum[SIGMA], t[SIZE]; void build_ST() &#123; rep(i, 2, cur) &#123; E[++en] = (edge) &#123; next[i], i, s[n - (right[i] - Max[next[i]]) + 1] - 'a', 0 &#125;; ++sum[E[en].w]; &#125; rep(i, 1, SIGMA - 1) sum[i] += sum[i - 1]; rep(i, 1, en) t[sum[E[i].w]--] = i; drep(i, en, 1) ae(t[i]); &#125; &#125; using namespace ST;&#125;using namespace SAM;void build_height()&#123; int j = 0; rep(i, 1, n) if(rnk[i] != n) &#123; while(s[i + j] == s[sa[rnk[i] + 1] + j]) ++j; height[rnk[i]] = j; if(j) --j; &#125;&#125;int main()&#123; init(); scanf("%s", s + 1); n = strlen(s + 1); drep(i, n, 1) extend(s[i] - 'a', i); build_ST(); build_sa(1); rep(i, 1, n) rnk[sa[i]] = i; build_height(); rep(i, 1, n) printf("%d ", sa[i]); puts(""); rep(i, 1, n - 1) printf("%d ", height[i]); puts(""); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UOJ207 共价大爷游长沙]]></title>
      <url>%2F2017%2F05%2F14%2FUOJ207%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 一棵树，四个操作:&emsp;&emsp;1、删边 + 加边&emsp;&emsp;2、加入点对(x, y)&emsp;&emsp;3、删除第x个加入的点对&emsp;&emsp;4、询问当前所有点对之间的路径是否均经过边(x, y) &emsp;&emsp;这道题是动态树维护虚边信息的好题。&emsp;&emsp;考察操作4，所有点对路径均经过边(x, y)，就代表着将x作为树根后，所有点对均有且只有一个点在y的子树中。(包括y)&emsp;&emsp;我们将每一条路径随机一个很大的权值，并异或到对应点对的两个点上。则x作为根并access(y)后，y的实子树中只有点x。那么所有路径有且只有一个点在y子树中-&gt;y及其虚子树异或和=所有路径异或和。当然以上成立的条件是随机出的权值没有重复，异或和也不能有重复的。在int范围内随机就可以避免这个问题了。&emsp;&emsp;维护一个所有路径异或和now和每个节点的信息，加入与删除路径点对时记得在总异或和与路径两端点权值中加上(清掉)该路径权值，异或一下就好。&emsp;&emsp;这道题需要维护子树和，由于是第一次练习，为了写得更模板化，我多使用了几个变量:&emsp;&emsp;val –&gt; 节点权值&emsp;&emsp;sum_chain –&gt; 节点实子树权值和(包括节点本身)&emsp;&emsp;val_tree –&gt; 节点虚子树权值和(不包括节点本身)&emsp;&emsp;sum_tree –&gt; 节点及其实子树所有节点的虚子树权值和(不包括实子树节点及本身)&emsp;&emsp;以上所有权值和在本题中均指异或和。&emsp;&emsp;前两项是平时维护的东西，后面多出来的两项是额外维护的东西。&emsp;&emsp;这些东西可以干很多事情,比如: sum_tree + sum_chain = 该节点为根的子树的和&emsp;&emsp;又比如，将加法换成异或，则val ^ val_tree 就是我们要找的节点及虚子树的异或和。&emsp;&emsp;在题目中，有些东西可以合在一起维护，具体问题具体分析。&emsp;&emsp;维护虚边信息的动态树在写法上面有改变，尤其是node中的access操作。要留心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define getchar getchar_unlockedtemplate&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 300010;struct node&#123; node *p, *c[2]; bool rev; int val_tree, val; int sum_tree, sum_chain; node(): p(0), rev(0), val_tree(0), val(0), sum_tree(0), sum_chain(0) &#123; ms(c, 0); &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; sum_tree = val_tree; sum_chain = val; rep(i, 0, 1) if(c[i]) &#123; sum_chain ^= c[i]-&gt;sum_chain; sum_tree ^= c[i]-&gt;sum_tree; &#125; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node *f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) &#123; u-&gt;splay(); if(u-&gt;c[1]) u-&gt;val_tree ^= u-&gt;c[1]-&gt;sum_tree ^ u-&gt;c[1]-&gt;sum_chain; if(v) u-&gt;val_tree ^= v-&gt;sum_tree ^ v-&gt;sum_chain; u-&gt;setc(v, 1), u-&gt;pushup(); &#125; splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn];int n, m, now;int a[maxm], cnt;pair&lt;int, int&gt; path[maxm];namespace LCT&#123; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v; v-&gt;val_tree ^= u-&gt;sum_tree ^ u-&gt;sum_chain; v-&gt;pushup(); &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; void change(int x, int y) &#123; node *u = nd + x; u-&gt;access(); u-&gt;val ^= y; u-&gt;pushup(); &#125; bool query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return (v-&gt;val ^ v-&gt;val_tree) == now; &#125;&#125;using namespace LCT;int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif srand(time(0)); scanf("%*d"); read(n); read(m); int x, y; rep(i, 1, n - 1) read(x), read(y), link(x, y); while(m--) &#123; int op; read(op); if(op == 1) &#123; read(x); read(y); cut(x, y); read(x); read(y); link(x, y); &#125; if(op == 2) &#123; read(x); read(y); int Hash = rand(); now ^= Hash; change(x, Hash); change(y, Hash); path[++cnt] = mp(x, y); a[cnt] = Hash; &#125; if(op == 3) &#123; read(x); change(path[x].first, a[x]); change(path[x].second, a[x]); now ^= a[x]; &#125; if(op == 4) read(x), read(y), puts(query(x, y) ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SPOJ1812 LCS2]]></title>
      <url>%2F2017%2F05%2F09%2FSPOJ1812%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你n个串，求它们的LCS。 &emsp;&emsp;后缀系列的经典问题。&emsp;&emsp;这道题用后缀数组+二分当然可以做。将n个串连接成一个长串，只需要每次二分LCP，看是否有n个后缀LCP大于该值，又正好分属n个串就好。&emsp;&emsp;但这个复杂度显然是$O(n \log n)$的，在这里过不了。我们考虑用SAM解决这个问题。&emsp;&emsp;首先我们从两个串的情况入手: (SPOJ LCS正是两串LCS的题目)&emsp;&emsp;将第一个串$s_1$的SAM构建出来，然后在上面运行第二个串$s_2$。记录一个到当前位的LCS长度，记作len。如果当前到了第i位，节点u有$s_2[i]$的转移边,则走转移边，len长度+1。如果没有该转移边，由于next边上节点所包含的串均为当前点u包含串的后缀，所以沿着next边向前走，走到第一个有该转移边的节点v。根据节点的定义，一个节点有转移边，则其中所有串均可以通过这条转移边到另一个合法子串。于是我们只需要取最长的一个。即走过v的转移边，将len重新赋值为$Max[v] + 1$。如果走到根都没有转移边的话，就从根重新开始，并将len赋值为0。每走一步更新答案即可。&emsp;&emsp;如何处理多个串的情况?我们对于每个节点多记录两个值，一个代表所有串运行到当前点时的LCS值，一个代表当前串运行到当前点时的LCS，即上面的len。注:一个串可能被运行到一个点多次，记录最大值即可。要注意的是，在之前的双串LCS中，我们忽略了一个东西:当我们运行到一个点，即代表这个点包含的串在原串出现时，该节点通过next边连接的所有点，即该串的所有后缀也都在原串出现了，所以之前的点的len值也需要更新。在两个串的情况里，运行到一个点时，其代表串的后缀显然不会更优，并不用在意这一点。但是在多串中，我们需要考虑其他串的影响，就要基数排序排出节点间的拓扑序，按照其逆序更新所有节点的真正len值。运行完一个串后，将每个节点的所有串运行到当前点的LCS值对当前len取min即可。(如果没运行到则len=0，说明该节点代表的串不会参与答案更新)&emsp;&emsp;最后运行完所有串后，所有节点LCS的max值就是答案了。&emsp;&emsp;这道题卡时间，多清空几个数组都会T。不过错误算法(不基数排序)可以水过去。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, SIZE = maxn &lt;&lt; 2, SIGMA = 26;namespace SAM&#123; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int LCS[SIZE], LEN[SIZE]; int cur, last; void init() &#123; cur = last = 1; &#125; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125;&#125;using namespace SAM;char s[maxn];int n, ans;int sum[maxn], t[SIZE];int main()&#123; init(); scanf("%s", s); n = strlen(s); rep(i, 0, n - 1) extend(s[i] - 'a'); rep(i, 1, cur) LCS[i] = Max[i]; rep(i, 1, cur) ++sum[Max[i]]; rep(i, 1, n) sum[i] += sum[i - 1]; drep(i, cur, 1) t[sum[Max[i]]--] = i; while(~scanf("%s", s)) &#123; int h = 1, len = 0; ms(LEN, 0); rep(i, 0, strlen(s) - 1) &#123; if(ch[h][s[i] - 'a']) ++len, h = ch[h][s[i] - 'a']; else &#123; while(h &amp;&amp; !ch[h][s[i] - 'a']) h = next[h]; if(!h) h = 1, len = 0; else len = Max[h] + 1, h = ch[h][s[i] - 'a']; &#125; chkmax(LEN[h], len); &#125; drep(i, cur, 1) chkmax(LEN[next[t[i]]], LEN[t[i]]); rep(i, 1, cur) chkmin(LCS[i], LEN[i]); &#125; rep(i, 1, cur) chkmax(ans, LCS[i]); printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[POJ1509 Glass Beads]]></title>
      <url>%2F2017%2F05%2F07%2FPOJ1509%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意:给你一个循环串(首尾相接)，求出使其字典序最小的起始位置。 &emsp;&emsp;后缀自动机(SAM)的第一道题。&emsp;&emsp;看后缀自动机有关的东西看了很久，差不多明白了一些。&emsp;&emsp;这道题其实本来有更加简单的暴力做法，不过就全当练习SAM了。&emsp;&emsp;首先将原串S扩展至两倍SS，这是循环串的惯用套路。&emsp;&emsp;接着将SAM增量构造出来，由于SAM包含了原串的所有子串，所以在SAM上，每次沿着字典序最小的边走，走$|S|$次，到达节点u一定包含要找的字典序最小的串。&emsp;&emsp;那么如何将其提取出来?也就是，如何在u表示的众多串中，找到那个串，并且知道其在原串中的起始位置呢?&emsp;&emsp;其实并不用找到那个串。注意到u表示的最长的串一定是从原串的开头到我们要找的串的末尾的。而根据SAM的性质，我们要找的串一定是最长串的后缀，且长度为n。于是$Max[u]-n+1$便是答案了。&emsp;&emsp;要注意一点:SAM中是否有某个节点是用其对应下标是否为0来判断的。所以SAM的start节点不能设为0。为了方便，设为1即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define ms(a, b) memset(a, b, sizeof a)const int maxn = 10010, SIZE = (maxn &lt;&lt; 3), SIGMA = 26;template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x)&#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;namespace SAM&#123; int cur, last; int ch[SIZE][SIGMA], next[SIZE], Max[SIZE]; int New(int x) &#123; Max[++cur] = x; return cur; &#125; void init() &#123; ms(next, 0); ms(Max, 0); ms(ch, 0); cur = last = 1; &#125; void extend(int c) &#123; int u = New(Max[last] + 1), v = last; for(; v &amp;&amp; !ch[v][c]; v = next[v]) ch[v][c] = u; if(!v) next[u] = 1; else &#123; int h = ch[v][c]; if(Max[h] == Max[v] + 1) next[u] = h; else &#123; int o = New(Max[v] + 1); memcpy(ch[o], ch[h], sizeof ch[h]); next[o] = next[h]; next[h] = next[u] = o; for(; v &amp;&amp; ch[v][c] == h; v = next[v]) ch[v][c] = o; &#125; &#125; last = u; &#125;&#125;using namespace SAM;char s[maxn];int n;int main()&#123; freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout); int _; read(_); while(_--) &#123; init(); scanf("%s", s); n = strlen(s); rep(i, 0, n - 1) extend(s[i] - 'a'); rep(i, 0, n - 1) extend(s[i] - 'a'); int h = 1; rep(i, 1, n) rep(c, 0, 25) if(ch[h][c]) &#123; h = ch[h][c]; break; &#125; printf("%d\n", Max[h] - n + 1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ4025 二分图]]></title>
      <url>%2F2017%2F05%2F04%2FBZOJ4025%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;题意: 给你一个图中每个点出现与消失的时刻，求在每一个时刻中该图是否为二分图。 &emsp;&emsp;这道题可以说是LCT维护动态生成树的集大成题。其中加入了二分图模型，对于以后很多的题目都具有启示意义。&emsp;&emsp;对于这道题，我们考虑维护以删除时间为关键字的最大生成树。对于整个图来说，就是一个最大生成森林。 &emsp;&emsp;在每一时刻，在生成森林中，对于每一条出现的边:&emsp;&emsp;如果该边两端不联通，则加入该边。&emsp;&emsp;如果该边两端联通，将该边连上后会出现一个环。&emsp;&emsp;如果这个环是奇环，那么将该环中删除时间最早(权值最小)的边删除，并加入标记集合，表示该边存在时，图不为二分图。&emsp;&emsp;具体实现的话，就是先将出现边与原路径中的最小边比较，如果比最小边要小，则直接判断是否为奇环加标记即可。&emsp;&emsp;如果比最小边要大，那么就删除最小边，连接上该边，将最小边拿去判断。 &emsp;&emsp;对于每一条删除的边:&emsp;&emsp;如果这条边在树上，直接cut。&emsp;&emsp;如果这条边在删除集合里，直接去掉。 &emsp;&emsp;每一个时刻，当且仅当集合内没有元素时，图为二分图。 &emsp;&emsp;维护生成树中最小/大边，我采用的是维护指针的方法。指针减去初指针就为实际下标了。&emsp;&emsp;判断是否为奇环，就维护LCT的size即可。注意边的size设为0。&emsp;&emsp;注意这道题的联通性不能用普通并查集，因为有cut操作。我直接暴力判断的联通性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;#define rep(i, l, r) for(int i = l, i##end = r; i &lt;= i##end; ++i)#define drep(i, l, r) for(int i = l, i##end = r; i &gt;= i##end; --i)#define mp make_pair#define ms(a, b) memset(a, b, sizeof a)#define pb push_back#define SZ(x) (int((x).size()))template&lt;class T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template&lt;class T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;template&lt;typename T&gt; inline T&amp; read(T&amp; x) &#123; static char c; bool flag = 0; while(!isdigit(c = getchar())) if(c == '-') flag = 1; for(x = c ^ 48; isdigit(c = getchar()); x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48)); if(flag) x = -x; return x;&#125;const int maxn = 100010, maxm = 200010, INF = 0x3f3f3f3f;struct node&#123; node *p, *c[2], *Min; bool rev, isdot; int val, sz; node(): p(0), Min(this), rev(0), val(INF) &#123; c[0] = c[1] = 0; &#125; void setc(node* o, bool b) &#123; c[b] = o; if(o) o-&gt;p = this; &#125; bool isroot() &#123; return !p || p-&gt;c[0] != this &amp;&amp; p-&gt;c[1] != this; &#125; bool getpos() &#123; return p-&gt;c[1] == this; &#125; void updrev() &#123; rev ^= 1; &#125; void pushup() &#123; Min = this; rep(i, 0, 1) if(c[i] &amp;&amp; c[i]-&gt;Min-&gt;val &lt; Min-&gt;val) Min = c[i]-&gt;Min; sz = isdot; rep(i, 0, 1) if(c[i]) sz += c[i]-&gt;sz; &#125; void pushdown() &#123; if(rev) &#123; rep(i, 0, 1) if(c[i]) c[i]-&gt;updrev(); swap(c[0], c[1]); rev = 0; &#125; &#125; void rot() &#123; node* f = p; bool b = getpos(); if(f-&gt;isroot()) p = f-&gt;p; else f-&gt;p-&gt;setc(this, f-&gt;getpos()); f-&gt;setc(c[!b], b); setc(f, !b); f-&gt;pushup(); &#125; void relax() &#123; if(!isroot()) p-&gt;relax(); pushdown(); &#125; void splay() &#123; for(relax(); !isroot(); rot()) if(!p-&gt;isroot()) (p-&gt;getpos() == getpos() ? p : this)-&gt;rot(); pushup(); &#125; void access() &#123; for(node *u = this, *v = 0; u; v = u, u = u-&gt;p) u-&gt;splay(), u-&gt;setc(v, 1), u-&gt;pushup(); splay(); &#125; void beroot() &#123; access(); updrev(); &#125;&#125;nd[maxn + maxm];int n, m, t;namespace LCT&#123; bool check(int x, int y) &#123; node *u = nd + x, *v = nd + y; while(u-&gt;p) u = u-&gt;p; while(v-&gt;p) v = v-&gt;p; return u == v; &#125; void link(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); u-&gt;p = v; &#125; void cut(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); u-&gt;p = v-&gt;c[0] = NULL; v-&gt;pushup(); &#125; node* query(int x, int y) &#123; node *u = nd + x, *v = nd + y; u-&gt;beroot(); v-&gt;access(); return v-&gt;Min; &#125;&#125;using namespace LCT;struct edge&#123; int u, v, w;&#125;E[maxm];vector&lt;int&gt; Add[maxn], Del[maxn];int cnt;bool inTree[maxm], inSet[maxm];int main()&#123;#ifndef ONLINE_JUDGE freopen("exec.in", "r", stdin); freopen("exec.out", "w", stdout);#endif read(n); read(m); read(t); int st, ed; rep(i, 1, m) &#123; read(E[i].u), read(E[i].v), read(st), E[i].w = read(ed); Add[st].pb(i); Del[ed].pb(i); &#125; rep(i, 1, n) (nd + i)-&gt;isdot = (nd + i)-&gt;sz = 1; rep(i, 1, m) &#123; (nd + n + i)-&gt;val = E[i].w; (nd + n + i)-&gt;isdot = (nd + n + i)-&gt;sz = 0; &#125; rep(k, 0, t - 1) &#123; rep(i, 0, SZ(Add[k]) - 1) &#123; int j = Add[k][i]; if(E[j].u == E[j].v) &#123; inSet[j] = 1; ++cnt; continue; &#125; if(!check(E[j].u, E[j].v)) &#123; link(E[j].u, j + n); link(E[j].v, j + n); inTree[j] = 1; &#125; else &#123; node* o = query(E[j].u, E[j].v); int h = o - nd - n; if(E[j].w &gt; o-&gt;val) &#123; if((nd + E[j].v)-&gt;sz &amp; 1) inSet[h] = 1, ++cnt; cut(E[h].u, h + n); cut(E[h].v, h + n); link(E[j].u, j + n); link(E[j].v, j + n); inTree[h] = 0; inTree[j] = 1; &#125; else if((nd + E[j].v)-&gt;sz &amp; 1) inSet[j] = 1, ++cnt; &#125; &#125; rep(i, 0, SZ(Del[k]) - 1) &#123; int j = Del[k][i]; if(inTree[j]) inTree[j] = 0, cut(E[j].u, j + n), cut(E[j].v , j + n); if(inSet[j]) inSet[j] = 0, --cnt; &#125; puts(cnt ? "No" : "Yes"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World!]]></title>
      <url>%2F2017%2F04%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在新站的第一篇博客。多多关照。 1printf("hello world\n");]]></content>
    </entry>

    
  
  
</search>
